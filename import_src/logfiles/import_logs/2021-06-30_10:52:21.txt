----------------
Import MetaInfo:

username: None
django_settings: django_settings.hsv_settings
collection: Import HSV full 22-6-21
spacy_model: using local model
existing_annotations: data/viecpro_HSV_0.jsonl
path_df: data/3_HSV-angepasst-IMPORT.xlsx
path_hofstaat: data/Kürzel-Hofstaate-EX-ACC-2021-06-02.xlsx
path_aemter: data/Kürzel-Ämter-ACC-EX-2021-02-08.xlsx
path_abbreviations: data/EXCEL-ACCESS_Kürzel-Titel-Orden-2021-01-28.xlsx
logger_level: 20
collection_team: ['MRomberg', 'MKaiser', 'CStandhartinger']
use_stopvalues: False
is_test: False
sample_frame: None
without_testing: True
log_msg: quick test
----------------


get_model >>> Used config cfg class for model configuration
----------------
Using the local model: models/viecpro_ner_hsv_5-21/

NLP-pipeline:
	ner
	use_existing_annotations
	add_brackets
	rename_functions
	remove_names
	date_prepocissions
	create_chunks
----------------


collection_counter = [(0, 'MRomberg (HSV)'), (3553, 'MKaiser (HSV)'), (7106, 'CStandhartinger (HSV)')]

--------- Start of row | 7106 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7106 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7107 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50105 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50105 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7107 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7108 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50110 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50110 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7108 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7109 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50115 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50115 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7109 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7110 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50120 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50120 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7110 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7111 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50125 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50125 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7111 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7112 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50130 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50130 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7112 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7113 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50135 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50135 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7113 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7114 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50140 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50140 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7114 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7115 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitting
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitting
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trabant'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trabant'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Trabant'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Trabantenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Trabant'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitting, Joachim>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Trabant']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Trabant
process_chunks >>>  Source Person Relation: 7115 -- Sitting, Joachim -- {'related_person': <Person: Sitting, Joachim>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Trabant>}

--------- Start of row | 7116 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sizi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sizi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sizi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50145 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50145 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7116 -- Sizi, Georg -- {'related_person': <Person: Sizi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7117 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sizy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sizy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sizy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50153 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50153 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7117 -- Sizy, Georg -- {'related_person': <Person: Sizy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7118 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Skräwarzs
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Skräwarzs
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Skräwarzs, Julius Eusebius>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 7118 -- Skräwarzs, Julius Eusebius -- {'related_person': <Person: Skräwarzs, Julius Eusebius>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 7119 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50158 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50158 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7119 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7120 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50166 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50166 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7120 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7121 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50171 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50171 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7121 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7122 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50176 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50176 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7122 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7123 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50181 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50181 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7123 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7124 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50186 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50186 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7124 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7125 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50191 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50191 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7125 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7126 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50196 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50196 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7126 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7127 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50201 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50201 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7127 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7128 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50206 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50206 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7128 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7129 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50211 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50211 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7129 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7130 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50216 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50216 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7130 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7131 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50221 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50221 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7131 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7132 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50226 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50226 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7132 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7133 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50231 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50231 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7133 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7134 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50236 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50236 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7134 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7135 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7135 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7136 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand Wilhelm>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50241 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50241 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7136 -- Slavata, Ferdinand Wilhelm -- {'related_person': <Person: Slavata, Ferdinand Wilhelm>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7137 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Hans Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50254 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50254 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7137 -- Slavata, Hans Joachim -- {'related_person': <Person: Slavata, Hans Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7138 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Hans Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50259 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50259 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7138 -- Slavata, Hans Joachim -- {'related_person': <Person: Slavata, Hans Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7139 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50264 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50264 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7139 -- Slavata, Joachim -- {'related_person': <Person: Slavata, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7140 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50269 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50269 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7140 -- Slavata, Johann -- {'related_person': <Person: Slavata, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7141 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7141 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7142 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (CF (Ksin.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7142 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: OMeA (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7143 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7143 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7144 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7144 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7145 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7145 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7146 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7146 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7147 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7147 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7148 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7148 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7149 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7149 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7150 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata (Sclawata)
person_process_field_familienname >>> fam1: Slavata
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Sclawata)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50274 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50274 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7150 -- Slavata, Joachim -- {'related_person': <Person: Slavata, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7151 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka (Schlawata)
person_process_field_familienname >>> fam1: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka
person_process_field_familienname >>> fam2: <re.Match object; span=(64, 75), match='(Schlawata)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50309 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50309 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7151 -- Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim -- {'related_person': <Person: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7152 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Socbey (?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Socbey ?
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Socbey ?, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7152 -- Socbey ?, NN -- {'related_person': <Person: Socbey ?, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7153 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sodiz/Hodiz(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sodiz/Hodiz?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sodiz/Hodiz?, Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50314 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50314 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7153 -- Sodiz/Hodiz?, Maximilian -- {'related_person': <Person: Sodiz/Hodiz?, Maximilian>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7154 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soewey [Sorbey; Sorbait, de?]
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Soewey [Sorbey; Sorbait, de?] END INPUT, ROW:7154
person_process_field_familienname >>> fam1: Soewey
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 29), match='[Sorbey; Sorbait, de?]'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soewey, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (EG (KW)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7154 -- Soewey, NN -- {'related_person': <Person: Soewey, NN>, 'related_institution': <Institution: OMeA (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7155 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söhlen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söhlen
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söhlen, Rudolph Caspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7155 -- Söhlen, Rudolph Caspar -- {'related_person': <Person: Söhlen, Rudolph Caspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7156 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sohlental (Söhlenthal)
person_process_field_familienname >>> fam1: Sohlental
person_process_field_familienname >>> fam2: <re.Match object; span=(10, 22), match='(Söhlenthal)'>
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenstand, AC
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sohlental, Rudolph Kaspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50334 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50334 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7156 -- Sohlental, Rudolph Kaspar -- {'related_person': <Person: Sohlental, Rudolph Kaspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7157 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söhlenthal
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söhlenthal
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söhlenthal, Rudolph Kaspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50341 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50341 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7157 -- Söhlenthal, Rudolph Kaspar -- {'related_person': <Person: Söhlenthal, Rudolph Kaspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7158 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soiber (Stöbern)
person_process_field_familienname >>> fam1: Soiber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 16), match='(Stöbern)'>
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Resident'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Resident'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Resident'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / kurfürst. Residenten
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Resident'], cH Dummy Hofstaat, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soiber, Johann Ferdinand>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name RHRat (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = RHRat (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Resident']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Resident
process_chunks >>>  Source Person Relation: 7158 -- Soiber, Johann Ferdinand -- {'related_person': <Person: Soiber, Johann Ferdinand>, 'related_institution': <Institution: RHRat (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Resident>}

--------- Start of row | 7159 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solar
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solar
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solar, Viktor Amadeus>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50322 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50322 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7159 -- Solar, Viktor Amadeus -- {'related_person': <Person: Solar, Viktor Amadeus>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7160 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solb [Selb]
person_process_field_familienname >>> fam1: Solb
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 11), match='[Selb]'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 7160 -- Solb, Johann Gabriel -- {'related_person': <Person: Solb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 7161 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solimanno
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solimanno
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Hoffuttermeister
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Postinbereiter', 'Pästinbereiter'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solimanno, Gabriel Francesco>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Postinbereiter', 'Pästinbereiter']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Postinbereiter
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Pästinbereiter
process_chunks >>>  Source Person Relation: 7161 -- Solimanno, Gabriel Francesco -- {'related_person': <Person: Solimanno, Gabriel Francesco>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Pästinbereiter>}

--------- Start of row | 7162 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7162 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7163 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50375 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50375 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7163 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7164 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50380 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50380 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7164 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7165 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50385 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50385 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7165 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7166 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll [Salla]
person_process_field_familienname >>> fam1: Soll
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='[Salla]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50390 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50390 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7166 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7167 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll [Salla]
person_process_field_familienname >>> fam1: Soll
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='[Salla]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50395 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50395 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7167 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7168 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solle
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solle
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ(?) / Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Regimentsrat']'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solle, Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ
chunk_process_amt >>> c_A was: NÖ and amt after matching with amt index is: NÖ (manuell), type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ (manuell) (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ (manuell) (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 7168 -- Solle, Maximilian -- {'related_person': <Person: Solle, Maximilian>, 'related_institution': <Institution: NÖ (manuell) (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 7169 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solliciti
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solliciti
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solliciti, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50400 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50400 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7169 -- Solliciti, Christian -- {'related_person': <Person: Solliciti, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7170 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollinti(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollinti?
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollinti?, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50411 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50411 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7170 -- Sollinti?, Christian -- {'related_person': <Person: Sollinti?, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7171 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollinti(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollinti?
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollinti?, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50416 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 50416 to NÖ Reg. (L1 (Ks.)), 50374
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7171 -- Sollinti?, Christian -- {'related_person': <Person: Sollinti?, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7172 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7172 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7173 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7173 -- Söllner, Eva -- {'related_person': <Person: Söllner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7174 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7174 -- Söllner, Eva -- {'related_person': <Person: Söllner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7175 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Silberwäscher'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Silberwäscher'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Johann Michael>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Silberwäscher']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Silberwäscher
process_chunks >>>  Source Person Relation: 7175 -- Söllner, Johann Michael -- {'related_person': <Person: Söllner, Johann Michael>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Silberwäscher>}

--------- Start of row | 7176 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Silberwäscher'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Silberwäscher'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Johann Michael>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 50436 to OMeA (J1 (Ehzg.)), 50435
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 50436 to OMeA (J1 (Ehzg.)), 50435
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (J1 (Ehzg.)) is OMeA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Silberwäscher']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Silberwäscher
process_chunks >>>  Source Person Relation: 7176 -- Söllner, Johann Michael -- {'related_person': <Person: Söllner, Johann Michael>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Silberwäscher>}

--------- Start of row | 7177 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söldner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söldner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7177 -- Sollner, NN -- {'related_person': <Person: Sollner, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7178 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söllner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söllner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7178 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7179 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söllner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söllner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7179 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7180 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Grafen- u. Herrenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50346 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 50346 to RHRat (L1 (Ks.)), 50333
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7180 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7181 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerpräsident'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerpräsident'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Kammerpräsident'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerpräsident'], cH Dummy Hofstaat, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Kammerpräsident']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerpräsident
process_chunks >>>  Source Person Relation: 7181 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Kammerpräsident>}

--------- Start of row | 7182 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Titular Geh. Rat,)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7182, Titular Geh. Rat, [{'start': 0, 'end': 16, 'token_start': 0, 'token_end': 3, 'label': 'FUNKTION'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Titular Geh. Rat]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Titular Geh. Rat,)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Titular Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50247 to Geh. Rat (L1 (Ks.)), 50246
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50247 to Geh. Rat (L1 (Ks.)), 50246
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Titular Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Titular Geh. Rat
process_chunks >>>  Source Person Relation: 7182 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Titular Geh. Rat>}

--------- Start of row | 7183 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommer
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Konzipist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Kanzleiverwandte
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Konzipist']'
process_chunks >>> cD [], cF ['Konzipist'], cH L, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommer, Niklas>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Konzipist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Konzipist
process_chunks >>>  Source Person Relation: 7183 -- Sommer, Niklas -- {'related_person': <Person: Sommer, Niklas>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Konzipist>}

--------- Start of row | 7184 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommer (Sammer)
person_process_field_familienname >>> fam1: Sommer
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sammer)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-HBH-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-HBH-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommer, Johann Konrad>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-HBH-NÖ-BH
chunk_process_amt >>> c_A was: HK-HBH-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7184 -- Sommer, Johann Konrad -- {'related_person': <Person: Sommer, Johann Konrad>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7185 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener, wirkl.'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener, wirkl.
process_chunks >>>  Source Person Relation: 7185 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener, wirkl.>}

--------- Start of row | 7186 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener, wirkl.'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 50482 to OKäA (J1 (Ehzg.)), 50481
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 50482 to OKäA (J1 (Ehzg.)), 50481
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener, wirkl.
process_chunks >>>  Source Person Relation: 7186 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener, wirkl.>}

--------- Start of row | 7187 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener'], cH Dummy Hofstaat, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name OKäA (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = OKäA (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7187 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7188 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somogyi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Somogyi
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz ' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz ' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somogyi, Franz >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7188 -- Somogyi, Franz  -- {'related_person': <Person: Somogyi, Franz >, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7189 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somogyi (Somogy)
person_process_field_familienname >>> fam1: Somogyi
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Somogy)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somogyi, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Ung. HKz (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 50496 to Ung. HKz (L1 (Ks.)), 50495
db_deduplicate_aemter >>> Set InstInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 50496 to Ung. HKz (L1 (Ks.)), 50495
db_deduplicate_aemter >>> Deleted obsolete Institution Ung. HKz (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Ung. HKz (L1 (Ks.)) is Ung. HKz (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7189 -- Somogyi, Franz -- {'related_person': <Person: Somogyi, Franz>, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7190 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somosa
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Somosa
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = MMT
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: MMT
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: MMT
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'MMT', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammerdienerinnen)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerdienerinnen)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerdienerinnen)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH MMT, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somosa, Antonia>}
chunk_get_nm_hst >>> c_H = MMT
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: MMT (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (MMT (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (MMT (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7190 -- Somosa, Antonia -- {'related_person': <Person: Somosa, Antonia>, 'related_institution': <Institution: Dummy Amt (MMT (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7191 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonces
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felice>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7191 -- Sonces, Felice -- {'related_person': <Person: Sonces, Felice>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7192 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces (Sances)
person_process_field_familienname >>> fam1: Sonces
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sances)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felice>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50510 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50510 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7192 -- Sonces, Felice -- {'related_person': <Person: Sonces, Felice>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7193 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces (Sances)
person_process_field_familienname >>> fam1: Sonces
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sances)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felici >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50515 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50515 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7193 -- Sonces, Felici  -- {'related_person': <Person: Sonces, Felici >, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7194 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonnau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonnau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonnau, Franz Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50354 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50354 to OKäA (L1 (Ks.)), 50104
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7194 -- Sonnau, Franz Anton -- {'related_person': <Person: Sonnau, Franz Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7195 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonniz(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonniz?
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonniz?, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 50360 to HK (L1 (Ks.)), 50359
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 50360 to HK (L1 (Ks.)), 50359
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 7195 -- Sonniz?, Johann -- {'related_person': <Person: Sonniz?, Johann>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 7196 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonntag
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonntag
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Buchhaltereioffizier'], cH Dummy Hofstaat, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonntag, Johann Georg>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ BH (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ BH (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Buchhaltereioffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Buchhaltereioffizier
process_chunks >>>  Source Person Relation: 7196 -- Sonntag, Johann Georg -- {'related_person': <Person: Sonntag, Johann Georg>, 'related_institution': <Institution: NÖ BH (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Buchhaltereioffizier>}

--------- Start of row | 7197 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> sonntag
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = sonntag
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG? / Buchhaltereioffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG?
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG?'
process_chunks >>> cD [], cF ['Buchhaltereioffizier'], cH Dummy Hofstaat, CA NÖ-LG?
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: sonntag, Johann Georg>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ-LG?
chunk_process_amt >>> amt NÖ-LG? was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt NÖ-LG? (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ-LG? (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Buchhaltereioffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Buchhaltereioffizier
process_chunks >>>  Source Person Relation: 7197 -- sonntag, Johann Georg -- {'related_person': <Person: sonntag, Johann Georg>, 'related_institution': <Institution: NÖ-LG? (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Buchhaltereioffizier>}

--------- Start of row | 7198 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonsky
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonsky
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Hofkanzler', 'Bischof'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonsky, Ladislaus Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Ung. HKz (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 50501 to Ung. HKz (L1 (Ks.)), 50495
db_deduplicate_aemter >>> Set InstInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 50501 to Ung. HKz (L1 (Ks.)), 50495
db_deduplicate_aemter >>> Deleted obsolete Institution Ung. HKz (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Ung. HKz (L1 (Ks.)) is Ung. HKz (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkanzler', 'Bischof']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkanzler
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Bischof
process_chunks >>>  Source Person Relation: 7198 -- Sonsky, Ladislaus Matthias -- {'related_person': <Person: Sonsky, Ladislaus Matthias>, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Bischof>}

--------- Start of row | 7199 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau [Saurau?]
person_process_field_familienname >>> fam1: Sorau
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 15), match='[Saurau?]'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 50104 to OKäA (L1 (Ks.)), 50525
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7199 -- Sorau, Johann Carl -- {'related_person': <Person: Sorau, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7200 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau, von [Serau, von]
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sorau, von [Serau, von] END INPUT, ROW:7200
person_process_field_familienname >>> fam1: Sorau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 23), match='[Serau, von]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7200 -- Sorau, von, NN -- {'related_person': <Person: Sorau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7201 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau, von [Serau, von]
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sorau, von [Serau, von] END INPUT, ROW:7201
person_process_field_familienname >>> fam1: Sorau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 23), match='[Serau, von]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7201 -- Sorau, von, NN -- {'related_person': <Person: Sorau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7202 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7202 -- Sorbait, Paul? -- {'related_person': <Person: Sorbait, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7203 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner', 'Hofdoktor'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner', 'Hofdoktor']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofdoktor
process_chunks >>>  Source Person Relation: 7203 -- Sorbait, Paul? -- {'related_person': <Person: Sorbait, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofdoktor>}

--------- Start of row | 7204 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7204 -- Sorbait, Paul? -- {'related_person': <Person: Sorbait, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7205 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA (Offiziere u.a. Bediente)
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA (Offiziere u.a. Bediente)' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA (Offiziere u.a. Bediente)' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (EG (KW)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (EG (KW)) from OMeA (EG (KW)), 50328 to OMeA (EG (KW)), 50327
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (EG (KW)) from OMeA (EG (KW)), 50328 to OMeA (EG (KW)), 50327
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (EG (KW))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (EG (KW)) is OMeA (EG (KW))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (EG (KW)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7205 -- Sorbait, NN -- {'related_person': <Person: Sorbait, NN>, 'related_institution': <Institution: OMeA (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7206 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (EG (KW)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (EG (KW)) from OMeA (EG (KW)), 50327 to OMeA (EG (KW)), 50565
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (EG (KW)) from OMeA (EG (KW)), 50327 to OMeA (EG (KW)), 50565
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (EG (KW))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (EG (KW)) is OMeA (EG (KW))
get_or_create_amt >>> Created amt_ent OMeA (EG (KW)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OMeA (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7206 -- Sorbait, NN -- {'related_person': <Person: Sorbait, NN>, 'related_institution': <Institution: OMeA (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7207 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorby)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 15), match='(Sorby)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner', 'Hofdoktor'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner', 'Hofdoktor']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofdoktor
process_chunks >>>  Source Person Relation: 7207 -- Sorbait, NN -- {'related_person': <Person: Sorbait, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofdoktor>}

--------- Start of row | 7208 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorby)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 15), match='(Sorby)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner', 'Hofdoktor'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner', 'Hofdoktor'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner', 'Hofdoktor']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofdoktor
process_chunks >>>  Source Person Relation: 7208 -- Sorbait, NN -- {'related_person': <Person: Sorbait, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofdoktor>}

--------- Start of row | 7209 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorobay)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Sorobay)'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OMeA (EG (KW)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OMeA (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7209 -- Sorbait, NN -- {'related_person': <Person: Sorbait, NN>, 'related_institution': <Institution: OMeA (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7210 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait, de (Sorbey)
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Sorbait, de (Sorbey) END INPUT, ROW:7210
person_process_field_familienname >>> fam1: Sorbait, de
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 20), match='(Sorbey)'>
person_process_field_titel >>> t_tit = Dr.
person_process_field_titel >>> t_list = ['Dr.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Offiziere u.a. Bediente)
helper_hsv_match_amt_with_funct >>> replaced amt '(Offiziere u.a. Bediente)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Offiziere u.a. Bediente)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, de, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7210 -- Sorbait, de, Paul? -- {'related_person': <Person: Sorbait, de, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7211 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait, de (Sorbey)
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Sorbait, de (Sorbey) END INPUT, ROW:7211
person_process_field_familienname >>> fam1: Sorbait, de
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 20), match='(Sorbey)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Offiziere u.a. Bediente)
helper_hsv_match_amt_with_funct >>> replaced amt '(Offiziere u.a. Bediente)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Offiziere u.a. Bediente)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbait, de, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7211 -- Sorbait, de, Paul? -- {'related_person': <Person: Sorbait, de, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7212 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbeit
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sorbeit
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbeit, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7212 -- Sorbeit, NN -- {'related_person': <Person: Sorbeit, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7213 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbey
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sorbey
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbey, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7213 -- Sorbey, NN -- {'related_person': <Person: Sorbey, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7214 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbey
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sorbey
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbey, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7214 -- Sorbey, NN -- {'related_person': <Person: Sorbey, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7215 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbey [Sorbait, de?]
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Sorbey [Sorbait, de?] END INPUT, ROW:7215
person_process_field_familienname >>> fam1: Sorbey
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 21), match='[Sorbait, de?]'>
person_process_field_titel >>> t_tit = Dr.
person_process_field_titel >>> t_list = ['Dr.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofdoktor'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofdoktor'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofdoktor'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofdoktor'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorbey, Paul?>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofdoktor']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofdoktor
process_chunks >>>  Source Person Relation: 7215 -- Sorbey, Paul? -- {'related_person': <Person: Sorbey, Paul?>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofdoktor>}

--------- Start of row | 7216 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sormani
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sormani
person_process_field_titel >>> t_tit = Comte
person_process_field_titel >>> t_list = ['Comte']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sormani, Antonio>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7216 -- Sormani, Antonio -- {'related_person': <Person: Sormani, Antonio>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7217 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sortellen?
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sortellen?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sortellen?, Friedrich>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7217 -- Sortellen?, Friedrich -- {'related_person': <Person: Sortellen?, Friedrich>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7218 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soto, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Soto, de END INPUT, ROW:7218
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soto, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Soto, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Dienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Dienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = MMT
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: MMT
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: MMT
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'MMT', 'FUNKTION': ['Dienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Frauenzimmerdienerinnen (Azafatos y de Tocas))
helper_hsv_match_amt_with_funct >>> replaced amt '(Frauenzimmerdienerinnen (Azafatos y de Tocas))' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Frauenzimmerdienerinnen (Azafatos y de Tocas))' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Dienerin'], cH MMT, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soto, de, Anna Maria>}
chunk_get_nm_hst >>> c_H = MMT
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: MMT (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (MMT (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (MMT (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Dienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Dienerin
process_chunks >>>  Source Person Relation: 7218 -- Soto, de, Anna Maria -- {'related_person': <Person: Soto, de, Anna Maria>, 'related_institution': <Institution: Dummy Amt (MMT (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Dienerin>}

--------- Start of row | 7219 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soto, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Soto, de END INPUT, ROW:7219
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soto, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Soto, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Kammerdienerin,)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7219, Kammerdienerin, Mayor, [{'token_start': 0, 'token_end': 0, 'start': 0, 'end': 14, 'text': 'Kammerdienerin', 'label': 'FUNKTION', 'source': '/nerdpool/models/viecpro_ner_hzab_12-20', 'input_hash': 788921816}, {'token_start': 2, 'token_end': 2, 'start': 16, 'end': 21, 'text': 'Mayor', 'label': 'FUNKTION', 'source': '/nerdpool/models/viecpro_ner_hzab_12-20', 'input_hash': 788921816}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Kammerdienerin, Mayor]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Kammerdienerin, Mayor)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin', 'Mayor'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin', 'Mayor'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = MMT
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: MMT
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: MMT
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'MMT', 'FUNKTION': ['Kammerdienerin', 'Mayor'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammerbedienstete (Las de la Camara))
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerbedienstete (Las de la Camara))' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerbedienstete (Las de la Camara))' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin', 'Mayor'], cH MMT, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soto, de, Maria>}
chunk_get_nm_hst >>> c_H = MMT
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: MMT (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (MMT (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (MMT (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin', 'Mayor']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mayor
process_chunks >>>  Source Person Relation: 7219 -- Soto, de, Maria -- {'related_person': <Person: Soto, de, Maria>, 'related_institution': <Institution: Dummy Amt (MMT (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Mayor>}

--------- Start of row | 7220 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souces, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souces, de END INPUT, ROW:7220
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souces, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souces, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souces, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7220 -- Souces, de, Ludwig Ratwig -- {'related_person': <Person: Souces, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7221 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souche (Souches, de)
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souche (Souches, de) END INPUT, ROW:7221
person_process_field_familienname >>> fam1: Souche
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 20), match='(Souches, de)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souche, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7221 -- Souche, Johann Ludwig -- {'related_person': <Person: Souche, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7222 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 7222 -- Souches, Carl ludwig -- {'related_person': <Person: Souches, Carl ludwig>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 7223 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7223 -- Souches, Carl ludwig -- {'related_person': <Person: Souches, Carl ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7224 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7224 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7225 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7225 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7226 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7226 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7227 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7227 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7228 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7228 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7229 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7229 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7230 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7230 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7231 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7231 -- Souches, Carl Ludwig -- {'related_person': <Person: Souches, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7232 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofdame'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofdame'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hofdame'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofdame'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Claudia>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hofdame']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofdame
process_chunks >>>  Source Person Relation: 7232 -- Souches, Claudia -- {'related_person': <Person: Souches, Claudia>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Hofdame>}

--------- Start of row | 7233 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Ernst Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7233 -- Souches, Ernst Ferdinand -- {'related_person': <Person: Souches, Ernst Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7234 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7234 -- Souches, Ferdinand -- {'related_person': <Person: Souches, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7235 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7235 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7236 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7236 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7237 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7237 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7238 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7238 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7239 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7239 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7240 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7240 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7241 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7241 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7242 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7242 -- Souches, Hanns Ludwig -- {'related_person': <Person: Souches, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7243 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hans ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7243 -- Souches, Hans ludwig -- {'related_person': <Person: Souches, Hans ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7244 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hans Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7244 -- Souches, Hans Ludwig -- {'related_person': <Person: Souches, Hans Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7245 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Hans Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7245 -- Souches, Hans Ludwig -- {'related_person': <Person: Souches, Hans Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7246 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7246 -- Souches, Johann Ludwig -- {'related_person': <Person: Souches, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7247 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7247 -- Souches, Johann Ludwig -- {'related_person': <Person: Souches, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7248 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7248 -- Souches, Johann Ludwig -- {'related_person': <Person: Souches, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7249 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7249 -- Souches, Johann Ludwig -- {'related_person': <Person: Souches, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7250 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7250 -- Souches, Johann Ludwig -- {'related_person': <Person: Souches, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7251 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Karl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7251 -- Souches, Karl Ludwig -- {'related_person': <Person: Souches, Karl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7252 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = de
person_process_field_titel >>> t_list = ['de']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7252 -- Souches, Lous Raduit -- {'related_person': <Person: Souches, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7253 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7253 -- Souches, Ludwig -- {'related_person': <Person: Souches, Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7254 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7254 -- Souches, Ludwig -- {'related_person': <Person: Souches, Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7255 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Geh. Rat, General, a.d.waras. Grenze)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7255, Geh. Rat u. General a.d.waras. Grenze, [{'start': 0, 'end': 8, 'token_start': 0, 'token_end': 2, 'label': 'FUNKTION'}, {'start': 12, 'end': 19, 'token_start': 4, 'token_end': 4, 'label': 'FUNKTION'}, {'start': 20, 'end': 37, 'token_start': 5, 'token_end': 7, 'label': 'AMT'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Geh. Rat, General, a.d.waras. Grenze]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Geh. Rat, General, a.d.waras. Grenze)
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Ludwig Radwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7255 -- Souches, Ludwig Radwig -- {'related_person': <Person: Souches, Ludwig Radwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7256 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, Maria Antonia>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7256 -- Souches, Maria Antonia -- {'related_person': <Person: Souches, Maria Antonia>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7257 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, NN>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 50487 to OKäA (J1 (Ehzg.)), 50481
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 50487 to OKäA (J1 (Ehzg.)), 50481
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7257 -- Souches, NN -- {'related_person': <Person: Souches, NN>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7258 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7258
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 7258 -- Souches, de, Carl -- {'related_person': <Person: Souches, de, Carl>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 7259 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7259
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Carl Joseph>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7259 -- Souches, de, Carl Joseph -- {'related_person': <Person: Souches, de, Carl Joseph>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7260 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7260
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7260 -- Souches, de, Carl Ludwig -- {'related_person': <Person: Souches, de, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7261 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7261
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7261 -- Souches, de, Carl Ludwig -- {'related_person': <Person: Souches, de, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7262 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7262
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Hanns Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7262 -- Souches, de, Hanns Ludwig -- {'related_person': <Person: Souches, de, Hanns Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7263 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7263
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7263 -- Souches, de, Johann Ludwig -- {'related_person': <Person: Souches, de, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7264 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7264
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Johann Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7264 -- Souches, de, Johann Ludwig -- {'related_person': <Person: Souches, de, Johann Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7265 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7265
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['General'], cH Dummy Hofstaat, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7265 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7266 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7266
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50462 to Geh. Rat (L1 (Ks.)), 50246
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50462 to Geh. Rat (L1 (Ks.)), 50246
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7266 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7267 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7267
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7267 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7268 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7268
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Geh. Rat, wirkl.u, General, a.d.waras. Grenze)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7268, Geh. Rat, wirkl.u. General a.d.waras. Grenze, [{'start': 0, 'end': 17, 'token_start': 0, 'token_end': 4, 'label': 'FUNKTION'}, {'start': 19, 'end': 26, 'token_start': 6, 'token_end': 6, 'label': 'FUNKTION'}, {'start': 27, 'end': 44, 'token_start': 7, 'token_end': 9, 'label': 'AMT'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Geh. Rat, wirkl.u, General, a.d.waras. Grenze]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Geh. Rat, wirkl.u, General, a.d.waras. Grenze)
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.u', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.u', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.u
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7268 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7269 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7269
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7269 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7270 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7270
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7270 -- Souches, de, Lous Raduit -- {'related_person': <Person: Souches, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7271 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7271
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7271 -- Souches, de, Ludwig -- {'related_person': <Person: Souches, de, Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7272 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7272
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7272 -- Souches, de, Ludwig -- {'related_person': <Person: Souches, de, Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7273 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7273
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7273 -- Souches, de, Ludwig -- {'related_person': <Person: Souches, de, Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7274 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7274
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Radwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7274 -- Souches, de, Ludwig Radwig -- {'related_person': <Person: Souches, de, Ludwig Radwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7275 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7275
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Radwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7275 -- Souches, de, Ludwig Radwig -- {'related_person': <Person: Souches, de, Ludwig Radwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7276 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7276
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Geh. Rat, wirkl.u, General, a.d.wind. Grenze)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7276, Geh. Rat, wirkl.u. General a.d.wind. Grenze, [{'start': 0, 'end': 17, 'token_start': 0, 'token_end': 4, 'label': 'FUNKTION'}, {'start': 19, 'end': 26, 'token_start': 6, 'token_end': 6, 'label': 'FUNKTION'}, {'start': 27, 'end': 43, 'token_start': 7, 'token_end': 9, 'label': 'AMT'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Geh. Rat, wirkl.u, General, a.d.wind. Grenze]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Geh. Rat, wirkl.u, General, a.d.wind. Grenze)
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.wind. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.wind. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.wind. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.wind. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.wind. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.wind. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.u', 'General'], cH L, CA a.d.wind. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Radwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.wind. Grenze
chunk_process_amt >>> amt a.d.wind. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.wind. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.wind. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.u', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.u
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7276 -- Souches, de, Ludwig Radwig -- {'related_person': <Person: Souches, de, Ludwig Radwig>, 'related_institution': <Institution: a.d.wind. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7277 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7277
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7277 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7278 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7278
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7278 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7279 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7279
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7279 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7280 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7280
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7280 -- Souches, de, Ludwig Ratwig  -- {'related_person': <Person: Souches, de, Ludwig Ratwig >, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7281 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7281
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.u', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.u', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.u', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.u
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7281 -- Souches, de, Ludwig Ratwig  -- {'related_person': <Person: Souches, de, Ludwig Ratwig >, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7282 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7282
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7282 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7283 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7283
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: waras. Grenze
chunk_process_amt >>> amt waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7283 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7284 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souches, de END INPUT, ROW:7284
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, de
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = a.d.waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, de, Ludwig Ratwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7284 -- Souches, de, Ludwig Ratwig -- {'related_person': <Person: Souches, de, Ludwig Ratwig>, 'related_institution': <Institution: a.d.waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7285 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souches, di
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souches, di
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Souches, di
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat', 'General'], 'AMT': 'waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = waras. Grenze
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'waras. Grenze'
process_chunks >>> cD [], cF ['Geh. Rat', 'General'], cH L, CA waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souches, di, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: waras. Grenze
chunk_process_amt >>> amt waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt waras. Grenze (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = waras. Grenze (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat', 'General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7285 -- Souches, di, NN -- {'related_person': <Person: Souches, di, NN>, 'related_institution': <Institution: waras. Grenze (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7286 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souchs
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souchs
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souchs, Carl Ludwig>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7286 -- Souchs, Carl Ludwig -- {'related_person': <Person: Souchs, Carl Ludwig>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7287 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souchs
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Souchs
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souchs, Ernst Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7287 -- Souchs, Ernst Ferdinand -- {'related_person': <Person: Souchs, Ernst Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7288 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souchs, de (Souches, de)
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souchs, de (Souches, de) END INPUT, ROW:7288
person_process_field_familienname >>> fam1: Souchs, de
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 24), match='(Souches, de)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = a.d.waras. Grenze
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['General'], 'AMT': 'a.d.waras. Grenze'}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'a.d.waras. Grenze'
process_chunks >>> cD [], cF ['General'], cH Dummy Hofstaat, CA a.d.waras. Grenze
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souchs, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: a.d.waras. Grenze
chunk_process_amt >>> amt a.d.waras. Grenze was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt a.d.waras. Grenze (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = a.d.waras. Grenze (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['General']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = General
process_chunks >>>  Source Person Relation: 7288 -- Souchs, de, Lous Raduit -- {'related_person': <Person: Souchs, de, Lous Raduit>, 'related_institution': <Institution: a.d.waras. Grenze (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: General>}

--------- Start of row | 7289 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Souchs, de (Souches, de)
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Souchs, de (Souches, de) END INPUT, ROW:7289
person_process_field_familienname >>> fam1: Souchs, de
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 24), match='(Souches, de)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Souchs, de, Lous Raduit>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50246 to Geh. Rat (L1 (Ks.)), 50757
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50246 to Geh. Rat (L1 (Ks.)), 50757
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50246 to Geh. Rat (L1 (Ks.)), 50757
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 50246 to Geh. Rat (L1 (Ks.)), 50757
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7289 -- Souchs, de, Lous Raduit -- {'related_person': <Person: Souchs, de, Lous Raduit>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7290 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soue
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soue
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soue, Johann Georg Friedrich>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7290 -- Soue, Johann Georg Friedrich -- {'related_person': <Person: Soue, Johann Georg Friedrich>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7291 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soye
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soye
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soye, Philipp Emanuel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7291 -- Soye, Philipp Emanuel -- {'related_person': <Person: Soye, Philipp Emanuel>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7292 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soye, de
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Soye, de END INPUT, ROW:7292
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soye, de
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Soye, de
person_process_field_titel >>> t_tit = Principiano Baron
person_process_field_titel >>> t_list = ['Principiano Baron']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soye, de, Philipp Emanuel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7292 -- Soye, de, Philipp Emanuel -- {'related_person': <Person: Soye, de, Philipp Emanuel>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7293 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soys
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soys
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soys, Ernst Friedrich Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7293 -- Soys, Ernst Friedrich Leopold -- {'related_person': <Person: Soys, Ernst Friedrich Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7294 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spacirer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spacirer
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sesselträger'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sesselträger'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sesselträger'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Hoffuttermeister
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Sesselträger'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spacirer, Johann Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OStA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 50368 to OStA (L1 (Ks.)), 50367
db_deduplicate_aemter >>> Set PersInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 50368 to OStA (L1 (Ks.)), 50367
db_deduplicate_aemter >>> Set InstInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 50368 to OStA (L1 (Ks.)), 50367
db_deduplicate_aemter >>> Deleted obsolete Institution OStA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OStA (L1 (Ks.)) is OStA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sesselträger']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sesselträger
process_chunks >>>  Source Person Relation: 7294 -- Spacirer, Johann Matthias -- {'related_person': <Person: Spacirer, Johann Matthias>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sesselträger>}

--------- Start of row | 7295 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Späckhl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Späckhl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR ' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR ' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Späckhl, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7295 -- Späckhl, NN -- {'related_person': <Person: Späckhl, NN>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7296 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Span von Spankau (Spaen von Spanckhau)
person_process_field_familienname >>> fam1: Span von Spankau
person_process_field_familienname >>> fam2: <re.Match object; span=(17, 38), match='(Spaen von Spanckhau)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> RenameFunctions.py >>> removing GWM from ents
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Span von Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50864 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50864 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7296 -- Span von Spankau, Alexander -- {'related_person': <Person: Span von Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7297 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanckau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanckau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanckau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50871 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50871 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7297 -- Spanckau, Alexander -- {'related_person': <Person: Spanckau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7298 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spänckau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spänckau
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spänckau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50876 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50876 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7298 -- Spänckau, Alexander -- {'related_person': <Person: Spänckau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7299 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanier [Spaur]
person_process_field_familienname >>> fam1: Spanier
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 15), match='[Spaur]'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanier, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7299 -- Spanier, Oswald -- {'related_person': <Person: Spanier, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7300 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spankau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50881 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50881 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7300 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7301 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spankau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50889 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50889 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7301 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7302 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau (Spanckhau)
person_process_field_familienname >>> fam1: Spankau
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 19), match='(Spanckhau)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50894 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50894 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7302 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7303 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau (Spankhau)
person_process_field_familienname >>> fam1: Spankau
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Spankhau)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50899 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50899 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7303 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7304 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau (Spankhau)
person_process_field_familienname >>> fam1: Spankau
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Spankhau)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50904 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50904 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7304 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7305 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankau (Spankhau)
person_process_field_familienname >>> fam1: Spankau
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Spankhau)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankau, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50909 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50909 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7305 -- Spankau, Alexander -- {'related_person': <Person: Spankau, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7306 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spankhaw
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spankhaw
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkriegsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Hofkriegsrat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spankhaw, Alexander>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50914 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50914 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkriegsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkriegsrat
process_chunks >>>  Source Person Relation: 7306 -- Spankhaw, Alexander -- {'related_person': <Person: Spankhaw, Alexander>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkriegsrat>}

--------- Start of row | 7307 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spannach
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spannach
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Offiziere u.a. Bediente/Mediziner, Hof-
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spannach, Johann Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50520 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 50520 to OMeA (L1 (Ks.)), 50509
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7307 -- Spannach, Johann Georg -- {'related_person': <Person: Spannach, Johann Georg>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7308 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7308 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7309 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7309 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7310 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7310 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7311 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7311 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7312 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7312 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7313 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7313 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7314 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7314 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7315 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spanz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammerfräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7315 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7316 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz (Spantzien)
person_process_field_familienname >>> fam1: Spanz
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 17), match='(Spantzien)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7316 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7317 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spanz (Spaz/Sporz(?))
person_process_field_familienname >>> fam1: Spanz
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 19), match='(Spaz/Sporz?)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spanz, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7317 -- Spanz, NN -- {'related_person': <Person: Spanz, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7318 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sparcher
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sparcher
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sparcher, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 50476 to NÖ BH (L1 (Ks.)), 50475
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 50476 to NÖ BH (L1 (Ks.)), 50475
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7318 -- Sparcher, Martin -- {'related_person': <Person: Sparcher, Martin>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7319 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spauer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spauer
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spauer, Leo Christoph>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7319 -- Spauer, Leo Christoph -- {'related_person': <Person: Spauer, Leo Christoph>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7320 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spauer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spauer
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spauer, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7320 -- Spauer, Oswald -- {'related_person': <Person: Spauer, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7321 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spauer, Plauen u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spauer, Plauen u. Vallör
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spauer, Plauen u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spauer, Plauen u. Vallör, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7321 -- Spauer, Plauen u. Vallör, Ferdinand -- {'related_person': <Person: Spauer, Plauen u. Vallör, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7322 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaun
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaun
person_process_field_titel >>> t_tit = JUD
person_process_field_titel >>> t_list = ['JUD']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Advokat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Advokat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Advokat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HKR / Advokaten
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR ' with 'HKR'
helper_hsv_match_amt_with_funct >>> replaced amt 'HKR ' with 'HKR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HKR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HKR'
process_chunks >>> cD [], cF ['Advokat'], cH L, CA HKR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaun, Franz Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HKR
chunk_process_amt >>> c_A was: HKR and amt after matching with amt index is: HKriegsRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HKriegsRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50919 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Set InstInst Relation for HKriegsRat (L1 (Ks.)) from HKriegsRat (L1 (Ks.)), 50919 to HKriegsRat (L1 (Ks.)), 50863
db_deduplicate_aemter >>> Deleted obsolete Institution HKriegsRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HKriegsRat (L1 (Ks.)) is HKriegsRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Kriegswesen
get_or_create_amt >>> Created amt_ent HKriegsRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HKriegsRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Advokat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Advokat
process_chunks >>>  Source Person Relation: 7322 -- Spaun, Franz Anton -- {'related_person': <Person: Spaun, Franz Anton>, 'related_institution': <Institution: HKriegsRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Advokat>}

--------- Start of row | 7323 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7323 -- Spaur, Anton -- {'related_person': <Person: Spaur, Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7324 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7324 -- Spaur, Carl -- {'related_person': <Person: Spaur, Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7325 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7325 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7326 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7326 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7327 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7327 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7328 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7328 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7329 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7329 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7330 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7330 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7331 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7331 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7332 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7332 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7333 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7333 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7334 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7334 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7335 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7335 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7336 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7336 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7337 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7337 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7338 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7338 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7339 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7339 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7340 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7340 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7341 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7341 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7342 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7342 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7343 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7343 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7344 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7344 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7345 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = ksl.
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: ksl.
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: ksl.
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'ksl.', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.'], cH ksl., CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = ksl.
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 7345 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}

--------- Start of row | 7346 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Anton Joseph>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7346 -- Spaur, Franz Anton Joseph -- {'related_person': <Person: Spaur, Franz Anton Joseph>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7347 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Daxis>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7347 -- Spaur, Franz Daxis -- {'related_person': <Person: Spaur, Franz Daxis>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7348 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7348 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7349 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7349 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7350 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7350 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7351 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7351 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7352 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7352 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7353 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7353 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7354 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7354 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7355 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7355 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7356 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7356 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7357 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7357 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7358 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7358 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7359 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7359 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7360 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7360 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7361 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7361 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7362 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7362 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7363 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7363 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7364 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7364 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7365 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7365 -- Spaur, Franz Paris -- {'related_person': <Person: Spaur, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7366 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7366 -- Spaur, Johann -- {'related_person': <Person: Spaur, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7367 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7367 -- Spaur, Johann Anton -- {'related_person': <Person: Spaur, Johann Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7368 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7368 -- Spaur, Johann Anton -- {'related_person': <Person: Spaur, Johann Anton>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7369 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7369 -- Spaur, Johann Anton -- {'related_person': <Person: Spaur, Johann Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7370 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = ksl.
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: ksl.
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: ksl.
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'ksl.', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.'], cH ksl., CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann Anton>}
chunk_get_nm_hst >>> c_H = ksl.
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 7370 -- Spaur, Johann Anton -- {'related_person': <Person: Spaur, Johann Anton>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}

--------- Start of row | 7371 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Joseph>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7371 -- Spaur, Joseph -- {'related_person': <Person: Spaur, Joseph>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7372 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7372 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7373 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7373 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7374 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7374 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7375 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7375 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7376 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7376 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7377 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7377 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7378 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7378 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7379 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7379 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7380 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7380 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7381 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7381 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7382 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7382 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7383 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7383 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7384 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7384 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7385 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7385 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7386 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7386 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7387 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7387 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7388 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7388 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7389 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7389 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7390 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Lepold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7390 -- Spaur, Lepold -- {'related_person': <Person: Spaur, Lepold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7391 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7391 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7392 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7392 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7393 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7393 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7394 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7394 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7395 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7395 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7396 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7396 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7397 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7397 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7398 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7398 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7399 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7399 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7400 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7400 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7401 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7401 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7402 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7402 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7403 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7403 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7404 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7404 -- Spaur, NN -- {'related_person': <Person: Spaur, NN>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7405 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur (Spauer)
person_process_field_familienname >>> fam1: Spaur
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Spauer)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7405 -- Spaur, Ferdinand -- {'related_person': <Person: Spaur, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7406 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur (Spauer)
person_process_field_familienname >>> fam1: Spaur
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Spauer)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7406 -- Spaur, Johann -- {'related_person': <Person: Spaur, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7407 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur (Spauer)
person_process_field_familienname >>> fam1: Spaur
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Spauer)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Leopold>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7407 -- Spaur, Leopold -- {'related_person': <Person: Spaur, Leopold>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7408 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur (Spauer)
person_process_field_familienname >>> fam1: Spaur
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Spauer)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, Oswald>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7408 -- Spaur, Oswald -- {'related_person': <Person: Spaur, Oswald>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7409 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7409 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7410 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7410 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7411 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7411 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7412 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7412 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7413 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7413 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7414 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7414 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7415 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7415 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7416 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7416 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7417 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7417 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7418 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7418 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7419 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7419 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7420 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7420 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7421 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7421 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7422 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Vallör
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7422 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7423 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Vallör (Spaur)
person_process_field_familienname >>> fam1: Spaur u. Vallör
person_process_field_familienname >>> fam2: <re.Match object; span=(16, 23), match='(Spaur)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Vallör, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7423 -- Spaur u. Vallör, Johann -- {'related_person': <Person: Spaur u. Vallör, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7424 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Wallor
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Wallor
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Wallor, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7424 -- Spaur u. Wallor, Johann -- {'related_person': <Person: Spaur u. Wallor, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7425 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Wollan [Spaur u. Vallör]
person_process_field_familienname >>> fam1: Spaur u. Wollan
person_process_field_familienname >>> fam2: <re.Match object; span=(16, 33), match='[Spaur u. Vallör]'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Wollan, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7425 -- Spaur u. Wollan, Johann -- {'related_person': <Person: Spaur u. Wollan, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7426 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Wollar
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Wollar
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Wollar, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7426 -- Spaur u. Wollar, Johann -- {'related_person': <Person: Spaur u. Wollar, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7427 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur u. Woller
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur u. Woller
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur u. Woller, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7427 -- Spaur u. Woller, Johann -- {'related_person': <Person: Spaur u. Woller, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7428 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7428
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, Franz Paris>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7428 -- Spaur, von, Franz Paris -- {'related_person': <Person: Spaur, von, Franz Paris>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7429 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7429
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Hoffräulein, Kammerfräulein)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7429, Hoffräulein (Kammerfräulein), [{'start': 0, 'end': 11, 'token_start': 0, 'token_end': 0, 'label': 'FUNKTION'}, {'start': 13, 'end': 27, 'token_start': 2, 'token_end': 2, 'label': 'FUNKTION'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Hoffräulein, Kammerfräulein]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Hoffräulein, Kammerfräulein)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, Maria>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7429 -- Spaur, von, Maria -- {'related_person': <Person: Spaur, von, Maria>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7430 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7430
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN, die jüngere>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7430 -- Spaur, von, NN, die jüngere -- {'related_person': <Person: Spaur, von, NN, die jüngere>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7431 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7431
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN, die jüngere>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7431 -- Spaur, von, NN, die jüngere -- {'related_person': <Person: Spaur, von, NN, die jüngere>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7432 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7432
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hoffräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN, jun.>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
process_chunks >>>  Source Person Relation: 7432 -- Spaur, von, NN, jun. -- {'related_person': <Person: Spaur, von, NN, jun.>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Hoffräulein>}

--------- Start of row | 7433 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7433
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, Theresia>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7433 -- Spaur, von, Theresia -- {'related_person': <Person: Spaur, von, Theresia>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7434 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7434
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7434 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7435 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7435
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7435 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7436 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7436
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7436 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7437 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7437
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7437 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7438 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7438
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7438 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7439 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7439
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7439 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7440 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7440
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7440 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7441 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7441
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7441 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7442 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7442
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7442 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7443 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7443
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7443 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7444 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7444
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7444 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7445 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7445
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7445 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7446 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7446
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7446 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7447 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7447
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7447 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7448 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7448
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7448 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7449 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7449
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7449 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7450 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7450
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7450 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7451 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7451
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7451 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7452 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7452
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7452 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7453 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7453
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammerfräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7453 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7454 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7454
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammerfräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7454 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7455 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7455
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7455 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7456 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7456
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7456 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7457 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7457
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7457 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7458 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7458
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7458 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7459 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7459
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hoffräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
process_chunks >>>  Source Person Relation: 7459 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Hoffräulein>}

--------- Start of row | 7460 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Spaur, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Spaur, von END INPUT, ROW:7460
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Spaur, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Spaur, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Hoffräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Spaur, von, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
process_chunks >>>  Source Person Relation: 7460 -- Spaur, von, NN -- {'related_person': <Person: Spaur, von, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Hoffräulein>}

--------- Start of row | 7461 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Speckel
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Speckel
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Landrechtsbeisitzer, Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD [], cF ['Sekretär', 'Beisitzer', 'Landrecht'], cH L, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Speckel, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Landmarsch. Gericht (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 50468 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 50468 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Landmarsch. Gericht (L1 (Ks.)) is NÖ Landmarsch. Gericht (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär', 'Beisitzer', 'Landrecht']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Beisitzer
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Landrecht
process_chunks >>>  Source Person Relation: 7461 -- Speckel, Johann -- {'related_person': <Person: Speckel, Johann>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Landrecht>}

--------- Start of row | 7462 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Speckel
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Speckel
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Landrechtsbeisitzer, Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD [], cF ['Sekretär', 'Beisitzer', 'Landrecht'], cH Dummy Hofstaat, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Speckel, Johann>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ Landmarsch. Gericht (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Sekretär', 'Beisitzer', 'Landrecht']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Beisitzer
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Landrecht
process_chunks >>>  Source Person Relation: 7462 -- Speckel, Johann -- {'related_person': <Person: Speckel, Johann>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Landrecht>}

--------- Start of row | 7463 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Speckel
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Speckel
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk HOFSTAAT = Landrechtsbeisitzer
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Landrechtsbeisitzer
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Landrechtsbeisitzer, Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD [], cF ['Sekretär'], cH Landrechtsbeisitzer, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Speckel, Johann>}
chunk_get_nm_hst >>> c_H = Landrechtsbeisitzer
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: Landrechtsbeisitzer
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (Landrechtsbeisitzer), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (Landrechtsbeisitzer)
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7463 -- Speckel, Johann -- {'related_person': <Person: Speckel, Johann>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (Landrechtsbeisitzer)>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7464 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Speckel (Spekhl)
person_process_field_familienname >>> fam1: Speckel
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Spekhl)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär', 'Beisitzer', 'Landrecht'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Landrechtsbeisitzer, Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD [], cF ['Sekretär', 'Beisitzer', 'Landrecht'], cH L, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Speckel, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Landmarsch. Gericht (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 51398 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 51398 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 51398 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 51398 to NÖ Landmarsch. Gericht (L1 (Ks.)), 50467
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Landmarsch. Gericht (L1 (Ks.)) is NÖ Landmarsch. Gericht (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär', 'Beisitzer', 'Landrecht']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Beisitzer
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Landrecht
process_chunks >>>  Source Person Relation: 7464 -- Speckel, Johann -- {'related_person': <Person: Speckel, Johann>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Landrecht>}

--------- Start of row | 7465 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Speckel (Spockhl)
person_process_field_familienname >>> fam1: Speckel
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Spockhl)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk HOFSTAAT = Landrechtsbeisitzer
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Landrechtsbeisitzer
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Landrechtsbeisitzer', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Landrechtsbeisitzer, Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD [], cF ['Sekretär'], cH Landrechtsbeisitzer, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Speckel, Johann>}
chunk_get_nm_hst >>> c_H = Landrechtsbeisitzer
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: Landrechtsbeisitzer
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Landmarsch. Gericht (Landrechtsbeisitzer). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (Landrechtsbeisitzer) from NÖ Landmarsch. Gericht (Landrechtsbeisitzer), 51411 to NÖ Landmarsch. Gericht (Landrechtsbeisitzer), 51410
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Landmarsch. Gericht (Landrechtsbeisitzer) from NÖ Landmarsch. Gericht (Landrechtsbeisitzer), 51411 to NÖ Landmarsch. Gericht (Landrechtsbeisitzer), 51410
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Landmarsch. Gericht (Landrechtsbeisitzer)
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Landmarsch. Gericht (Landrechtsbeisitzer) is NÖ Landmarsch. Gericht (Landrechtsbeisitzer)
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (Landrechtsbeisitzer), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (Landrechtsbeisitzer)
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7465 -- Speckel, Johann -- {'related_person': <Person: Speckel, Johann>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (Landrechtsbeisitzer)>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7466 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Specker
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Specker
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Specker, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 50475 to NÖ BH (L1 (Ks.)), 50959
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 50475 to NÖ BH (L1 (Ks.)), 50959
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7466 -- Specker, Martin -- {'related_person': <Person: Specker, Martin>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7467 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Specker
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Specker
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Specker, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7467 -- Specker, Martin -- {'related_person': <Person: Specker, Martin>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7468 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Specker (Sparckher)
person_process_field_familienname >>> fam1: Specker
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 19), match='(Sparckher)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Specker, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7468 -- Specker, Martin -- {'related_person': <Person: Specker, Martin>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7469 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Specker (Spärckher)
person_process_field_familienname >>> fam1: Specker
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 19), match='(Spärckher)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Specker, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super False
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7469 -- Specker, Martin -- {'related_person': <Person: Specker, Martin>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7470 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Specker (Speckher)
person_process_field_familienname >>> fam1: Specker
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Speckher)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Specker, Martin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
