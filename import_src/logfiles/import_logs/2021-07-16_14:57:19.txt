----------------
Import MetaInfo:

username: None
django_settings: django_settings.hsv_settings
collection: Import HSV full 22-6-21
spacy_model: using local model
existing_annotations: data/viecpro_HSV_0.jsonl
path_df: data/3_HSV-angepasst-IMPORT.xlsx
path_hofstaat: data/Kürzel-Hofstaate-EX-ACC-2021-06-02.xlsx
path_aemter: data/Kürzel-Ämter-ACC-EX-2021-02-08.xlsx
path_abbreviations: data/EXCEL-ACCESS_Kürzel-Titel-Orden-2021-01-28.xlsx
logger_level: 20
collection_team: ['MRomberg', 'MKaiser', 'CStandhartinger']
use_stopvalues: False
is_test: False
sample_frame: None
without_testing: True
log_msg: quick test
----------------


get_model >>> Used config cfg class for model configuration
----------------
Using the local model: models/viecpro_ner_hsv_5-21/

NLP-pipeline:
	ner
	use_existing_annotations
	add_brackets
	rename_functions
	remove_names
	date_prepocissions
	create_chunks
----------------


collection_counter = [(0, 'MRomberg (HSV)'), (3414, 'MKaiser (HSV)'), (6828, 'CStandhartinger (HSV)')]

--------- Start of row | 6828 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber', 'Hoflichtkämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber', 'Hoflichtkämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kellerschreiber', 'Hoflichtkämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kellerschreiber', 'Hoflichtkämmerer'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Bartholomäus>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kellerschreiber', 'Hoflichtkämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kellerschreiber
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hoflichtkämmerer
process_chunks >>>  Source Person Relation: 6828 -- Seiz, Bartholomäus -- {'related_person': <Person: Seiz, Bartholomäus>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hoflichtkämmerer>}

--------- Start of row | 6829 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6829 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6830 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 17 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 17 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6830 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6831 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ(?) / Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Regimentsrat']'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ
chunk_process_amt >>> c_A was: NÖ and amt after matching with amt index is: NÖ (manuell), type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ (manuell) (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ (manuell) (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6831 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ (manuell) (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6832 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 24 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 24 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6832 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6833 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 35 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 35 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6833 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6834 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Heitz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Heitz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat', 'Regierungsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 40 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 40 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat', 'Regierungsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Regierungsrat
process_chunks >>>  Source Person Relation: 6834 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regierungsrat>}

--------- Start of row | 6835 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Saiz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 11), match='(Saiz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 45 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 45 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 45 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6835 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6836 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seithes)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 14), match='(Seithes)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 51 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 51 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6836 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6837 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seiths)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 13), match='(Seiths)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 56 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 56 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6837 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6838 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seits)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seits)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 61 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 61 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6838 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6839 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seitz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seitz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 66 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 66 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6839 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6840 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seitz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seitz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 71 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 71 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6840 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6841 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seitz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seitz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 76 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 76 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6841 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6842 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seitz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seitz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 81 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 81 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6842 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6843 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seutz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seutz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = kgl. Lichtkammer
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Aufsicht', 'Kellerschreiber'], 'AMT': 'kgl. Lichtkammer'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Aufsicht', 'Kellerschreiber'], 'AMT': 'kgl. Lichtkammer'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Aufsicht', 'Kellerschreiber'], 'AMT': 'kgl. Lichtkammer'}
helper_hsv_match_amt_with_funct >>> r_A = OMeA [Hofkontrolloramt?]
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA [Hofkontrolloramt?]' with 'OMeA [Hofkontrolloramt?]'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA [Hofkontrolloramt?]' with 'OMeA [Hofkontrolloramt?]'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = kgl. Lichtkammer
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'kgl. Lichtkammer'
process_chunks >>> cD [], cF ['Aufsicht', 'Kellerschreiber'], cH J, CA kgl. Lichtkammer
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Bartholomäus>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: kgl. Lichtkammer
chunk_process_amt >>> amt kgl. Lichtkammer was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt kgl. Lichtkammer (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = kgl. Lichtkammer (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Aufsicht', 'Kellerschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Aufsicht
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kellerschreiber
process_chunks >>>  Source Person Relation: 6843 -- Seiz, Bartholomäus -- {'related_person': <Person: Seiz, Bartholomäus>, 'related_institution': <Institution: kgl. Lichtkammer (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kellerschreiber>}

--------- Start of row | 6844 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz (Seutz)
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seutz)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = kgl. Lichtkammer
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber', 'Aufsicht'], 'AMT': 'kgl. Lichtkammer'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber', 'Aufsicht'], 'AMT': 'kgl. Lichtkammer'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kellerschreiber', 'Aufsicht'], 'AMT': 'kgl. Lichtkammer'}
helper_hsv_match_amt_with_funct >>> r_A = OMeA [Hofkontrolloramt?]
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA [Hofkontrolloramt?]' with 'OMeA [Hofkontrolloramt?]'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA [Hofkontrolloramt?]' with 'OMeA [Hofkontrolloramt?]'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = kgl. Lichtkammer
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'kgl. Lichtkammer'
process_chunks >>> cD [], cF ['Kellerschreiber', 'Aufsicht'], cH J, CA kgl. Lichtkammer
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Bartholomäus>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: kgl. Lichtkammer
chunk_process_amt >>> amt kgl. Lichtkammer was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt kgl. Lichtkammer (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = kgl. Lichtkammer (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kellerschreiber', 'Aufsicht']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kellerschreiber
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Aufsicht
process_chunks >>>  Source Person Relation: 6844 -- Seiz, Bartholomäus -- {'related_person': <Person: Seiz, Bartholomäus>, 'related_institution': <Institution: kgl. Lichtkammer (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Aufsicht>}

--------- Start of row | 6845 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz [Seiths]
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 13), match='[Seiths]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 86 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 86 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6845 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6846 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz [Seiths]
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 13), match='[Seiths]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 100 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 100 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6846 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6847 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seiz [Seiths]
person_process_field_familienname >>> fam1: Seiz
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 13), match='[Seiths]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regierungsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regierungsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seiz, Johann Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 105 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 105 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regierungsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regierungsrat
process_chunks >>>  Source Person Relation: 6847 -- Seiz, Johann Michael -- {'related_person': <Person: Seiz, Johann Michael>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regierungsrat>}

--------- Start of row | 6848 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regierungsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RKz / Herrenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RKz ' with 'NÖ-RKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RKz ' with 'NÖ-RKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RKz'
process_chunks >>> cD [], cF ['Regierungsrat'], cH L, CA NÖ-RKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RKz
chunk_process_amt >>> c_A was: NÖ-RKz and amt after matching with amt index is: NÖ RegKz., type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ RegKz. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ RegKz. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regierungsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regierungsrat
process_chunks >>>  Source Person Relation: 6848 -- Selb, Johann Franz -- {'related_person': <Person: Selb, Johann Franz>, 'related_institution': <Institution: NÖ RegKz. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regierungsrat>}

--------- Start of row | 6849 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['bis 1705-03-11<1705-03-11>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['bis 1705-03-11<1705-03-11>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['bis 1705-03-11<1705-03-11>'], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['bis 1705-03-11<1705-03-11>'], cF ['Regimentsrat'], cH Dummy Hofstaat, CA Dummy Amt
helper_hsv_post_process_dates >>> inner date: <1705-03-11>
helper_hsv_post_process_dates >>> new_i_date: <1705-03-11>
helper_hsv_post_process_dates >>> old: bis 1705-03-11<1705-03-11>, new: bis 1705-03-11<1705-03-11>
chunk_process_datum >>> rel, chunk edw: bis 1705-03-11<1705-03-11>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Franz>, 'end_date_written': 'bis 1705-03-11<1705-03-11>'}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6849 -- Selb, Johann Franz -- {'related_person': <Person: Selb, Johann Franz>, 'end_date_written': 'bis 1705-03-11<1705-03-11>', 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6850 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6850 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6851 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 126 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 126 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6851 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6852 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 133 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 133 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6852 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6853 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 138 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 138 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6853 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6854 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 143 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 143 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6854 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6855 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 148 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 148 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6855 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6856 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 153 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 153 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6856 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6857 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 158 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 158 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6857 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6858 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 163 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 163 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6858 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6859 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkamerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkamerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkamerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkamerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 168 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 168 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkamerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofkamerrat
process_chunks >>>  Source Person Relation: 6859 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkamerrat>}

--------- Start of row | 6860 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 173 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 173 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6860 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6861 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 178 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 178 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6861 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6862 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 183 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 183 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6862 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6863 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 188 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 188 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6863 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6864 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 193 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 193 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6864 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6865 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 198 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 198 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6865 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6866 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> t_list = ['Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04']
person_process_field_titel >>> Komma in tit: Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> CREATING SPLIT TITLE Freiherr from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1663-00-00, new: 1663<1663-06-30>
create_title >>> tit_res: Rittereichsritter 1663-00-00, date after processing: 1663<1663-06-30>
person_process_field_titel >>> CREATING SPLIT TITLE Reichsritter 1663-00-00 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1673-03-04, new: 1673-03-04<1673-03-04>
create_title >>> tit_res: Rittereichs-u.erbländ. Freiherrenstand 1673-03-04, date after processing: 1673-03-04<1673-03-04>
person_process_field_titel >>> CREATING SPLIT TITLE Reichs-u.erbländ. Freiherrenstand 1673-03-04 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['NÖ Kammerprokurator'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['NÖ Kammerprokurator'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['NÖ Kammerprokurator'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['NÖ Kammerprokurator'], cH Dummy Hofstaat, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['NÖ Kammerprokurator']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = NÖ Kammerprokurator
process_chunks >>>  Source Person Relation: 6866 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: NÖ Kammerprokurator>}

--------- Start of row | 6867 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> t_list = ['Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04']
person_process_field_titel >>> Komma in tit: Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> CREATING SPLIT TITLE Freiherr from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1663-00-00, new: 1663<1663-06-30>
create_title >>> tit_res: Rittereichsritter 1663-00-00, date after processing: 1663<1663-06-30>
person_process_field_titel >>> CREATING SPLIT TITLE Reichsritter 1663-00-00 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1673-03-04, new: 1673-03-04<1673-03-04>
create_title >>> tit_res: Rittereichs-u.erbländ. Freiherrenstand 1673-03-04, date after processing: 1673-03-04<1673-03-04>
person_process_field_titel >>> CREATING SPLIT TITLE Reichs-u.erbländ. Freiherrenstand 1673-03-04 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1658-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1658-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1658-00-00'], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1658-00-00'], cF ['Hofkammerrat'], cH Dummy Hofstaat, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1658-00-00, new: 1658<1658-06-30>
chunk_process_datum >>> rel, chunk sdw: 1658<1658-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>, 'start_date_written': '1658<1658-06-30>'}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6867 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'start_date_written': '1658<1658-06-30>', 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6868 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> t_list = ['Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04']
person_process_field_titel >>> Komma in tit: Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> CREATING SPLIT TITLE Freiherr from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1663-00-00, new: 1663<1663-06-30>
create_title >>> tit_res: Rittereichsritter 1663-00-00, date after processing: 1663<1663-06-30>
person_process_field_titel >>> CREATING SPLIT TITLE Reichsritter 1663-00-00 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1673-03-04, new: 1673-03-04<1673-03-04>
create_title >>> tit_res: Rittereichs-u.erbländ. Freiherrenstand 1673-03-04, date after processing: 1673-03-04<1673-03-04>
person_process_field_titel >>> CREATING SPLIT TITLE Reichs-u.erbländ. Freiherrenstand 1673-03-04 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Abgesandter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Abgesandter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Abgesandter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Abgesandter'], cH Dummy Hofstaat, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Abgesandter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Abgesandter
process_chunks >>>  Source Person Relation: 6868 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Abgesandter>}

--------- Start of row | 6869 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb
person_process_field_titel >>> t_tit = Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> t_list = ['Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04']
person_process_field_titel >>> Komma in tit: Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
person_process_field_titel >>> CREATING SPLIT TITLE Freiherr from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1663-00-00, new: 1663<1663-06-30>
create_title >>> tit_res: Rittereichsritter 1663-00-00, date after processing: 1663<1663-06-30>
person_process_field_titel >>> CREATING SPLIT TITLE Reichsritter 1663-00-00 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
helper_hsv_post_process_dates >>> old: 1673-03-04, new: 1673-03-04<1673-03-04>
create_title >>> tit_res: Rittereichs-u.erbländ. Freiherrenstand 1673-03-04, date after processing: 1673-03-04<1673-03-04>
person_process_field_titel >>> CREATING SPLIT TITLE Reichs-u.erbländ. Freiherrenstand 1673-03-04 from Freiherr, Reichsritter 1663-00-00, Reichs-u.erbländ. Freiherrenstand 1673-03-04
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1664-00-00', 'bis 1678<1678-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1664-00-00', 'bis 1678<1678-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1664-00-00', 'bis 1678<1678-06-30>'], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1664-00-00', 'bis 1678<1678-06-30>'], cF ['Regimentsrat'], cH Dummy Hofstaat, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1664-00-00, new: 1664<1664-06-30>
helper_hsv_post_process_dates >>> inner date: <1678-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1678-06-30>
helper_hsv_post_process_dates >>> old: bis 1678<1678-06-30>, new: bis 1678<1678-06-30>
chunk_process_datum >>> rel, chunk sdw: 1664<1664-06-30>
chunk_process_datum >>> rel, chunk edw: 1664<1664-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Gabriel>, 'start_date_written': '1664<1664-06-30>', 'end_date_written': 'bis 1678<1678-06-30>'}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6869 -- Selb, Johann Gabriel -- {'related_person': <Person: Selb, Johann Gabriel>, 'start_date_written': '1664<1664-06-30>', 'end_date_written': 'bis 1678<1678-06-30>', 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6870 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb (Seelb)
person_process_field_familienname >>> fam1: Selb
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Seelb)'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Herrenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regimentsrat'], cH Dummy Hofstaat, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, Johann Franz>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ Reg. (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 6870 -- Selb, Johann Franz -- {'related_person': <Person: Selb, Johann Franz>, 'related_institution': <Institution: NÖ Reg. (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 6871 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Selb, von END INPUT, ROW:6871
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Selb, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, von, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 203 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 203 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6871 -- Selb, von, Johann Gabriel -- {'related_person': <Person: Selb, von, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6872 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selb, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Selb, von END INPUT, ROW:6872
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selb, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Selb, von
person_process_field_titel >>> t_tit = [Freiherr]
person_process_field_titel >>> t_list = ['[Freiherr]']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selb, von, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 219 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 219 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6872 -- Selb, von, Johann Gabriel -- {'related_person': <Person: Selb, von, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6873 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selcke
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selcke
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Agent'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Agent'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Agent'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = BHR / Agenten
helper_hsv_match_amt_with_funct >>> replaced amt 'BHR ' with 'BHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'BHR ' with 'BHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = BHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'BHR'
process_chunks >>> cD [], cF ['Agent'], cH L, CA BHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selcke, Michael>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: BHR
chunk_process_amt >>> c_A was: BHR and amt after matching with amt index is: Böhm. HRat , type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Böhm. HRat  (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Böhm. HRat  (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Agent']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Agent
process_chunks >>>  Source Person Relation: 6873 -- Selcke, Michael -- {'related_person': <Person: Selcke, Michael>, 'related_institution': <Institution: Böhm. HRat  (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Agent>}

--------- Start of row | 6874 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selder, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Selder, von END INPUT, ROW:6874
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selder, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Selder, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Ritterstand
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selder, von, Adam>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 224 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 224 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6874 -- Selder, von, Adam -- {'related_person': <Person: Selder, von, Adam>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6875 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selleburg, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Selleburg, von END INPUT, ROW:6875
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selleburg, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Selleburg, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selleburg, von, Franz Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6875 -- Selleburg, von, Franz Ferdinand -- {'related_person': <Person: Selleburg, von, Franz Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6876 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sellier
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sellier
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoftänzer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoftänzer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hoftänzer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hoftänzer'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sellier, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hoftänzer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hoftänzer
process_chunks >>>  Source Person Relation: 6876 -- Sellier, NN -- {'related_person': <Person: Sellier, NN>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hoftänzer>}

--------- Start of row | 6877 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Selliers
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Selliers
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = ME
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: ME
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: ME
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'ME', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kammerdiener'], cH ME, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Selliers, Rupert Niklas>}
chunk_get_nm_hst >>> c_H = ME
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: ME (L1)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (ME (L1)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (ME (L1))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 6877 -- Selliers, Rupert Niklas -- {'related_person': <Person: Selliers, Rupert Niklas>, 'related_institution': <Institution: OMeA (ME (L1))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 6878 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Semse
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Semse
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Semse, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 235 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 235 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 6878 -- Semse, Matthias -- {'related_person': <Person: Semse, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 6879 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Senipoffsky
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Senipoffsky
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Senipoffsky, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6879 -- Senipoffsky, NN -- {'related_person': <Person: Senipoffsky, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6880 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seragli
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seragli
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkaplan'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkaplan'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = LW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: LW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: LW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'LW', 'FUNKTION': ['Hofkaplan'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kaplan, Hof-
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofkaplan'], cH LW, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seragli, Domenico>}
chunk_get_nm_hst >>> c_H = LW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: LW
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (LW)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (LW)
chunk_create_relations >>> create relations called for c_F ['Hofkaplan']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofkaplan
process_chunks >>>  Source Person Relation: 6880 -- Seragli, Domenico -- {'related_person': <Person: Seragli, Domenico>, 'related_institution': <Institution: Dummy Amt (LW)>, 'relation_type': <PersonInstitutionRelation: Hofkaplan>}

--------- Start of row | 6881 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Hanns Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 6881 -- Serau, Hanns Georg -- {'related_person': <Person: Serau, Hanns Georg>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 6882 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Hanns Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 247 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 247 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 6882 -- Serau, Hanns Georg -- {'related_person': <Person: Serau, Hanns Georg>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 6883 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Edelknabe'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Edelknabe'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Hanns Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Edelknabe']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Edelknabe
process_chunks >>>  Source Person Relation: 6883 -- Serau, Hanns Georg -- {'related_person': <Person: Serau, Hanns Georg>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Edelknabe>}

--------- Start of row | 6884 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = ksl.
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: ksl.
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: ksl.
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'ksl.', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.'], cH ksl., CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Adam>}
chunk_get_nm_hst >>> c_H = ksl.
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 6884 -- Serau, Johann Adam -- {'related_person': <Person: Serau, Johann Adam>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}

--------- Start of row | 6885 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 259 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 259 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6885 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6886 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 295 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 295 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6886 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6887 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 300 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 300 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6887 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6888 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 305 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 305 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6888 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6889 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 310 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 310 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6889 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6890 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 315 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 315 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6890 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6891 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 320 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 320 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6891 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6892 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 325 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 325 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6892 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6893 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 330 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 330 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6893 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6894 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Johann Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 335 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 335 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6894 -- Serau, Johann Maximilian -- {'related_person': <Person: Serau, Johann Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6895 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 340 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 340 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 6895 -- Serau, Maximilian -- {'related_person': <Person: Serau, Maximilian>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 6896 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Sigmund Friedrich>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 241 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 241 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6896 -- Serau, Sigmund Friedrich -- {'related_person': <Person: Serau, Sigmund Friedrich>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6897 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, Wilhelm Erasmus>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 350 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 350 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6897 -- Serau, Wilhelm Erasmus -- {'related_person': <Person: Serau, Wilhelm Erasmus>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6898 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von END INPUT, ROW:6898
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Serau, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6898 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6899 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von END INPUT, ROW:6899
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Serau, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6899 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6900 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von END INPUT, ROW:6900
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Serau, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6900 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6901 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von END INPUT, ROW:6901
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Serau, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hoffräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
process_chunks >>>  Source Person Relation: 6901 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hoffräulein>}

--------- Start of row | 6902 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von (Saurau, von?)
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von (Saurau, von?) END INPUT, ROW:6902
person_process_field_familienname >>> fam1: Serau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 25), match='(Saurau, von?)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6902 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6903 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von (Saurau, von?)
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von (Saurau, von?) END INPUT, ROW:6903
person_process_field_familienname >>> fam1: Serau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 25), match='(Saurau, von?)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6903 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6904 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau, von (Saurau, von?)
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Serau, von (Saurau, von?) END INPUT, ROW:6904
person_process_field_familienname >>> fam1: Serau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 25), match='(Saurau, von?)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6904 -- Serau, von, NN -- {'related_person': <Person: Serau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6905 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serau/Saurau(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serau/Saurau?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serau/Saurau?, Georg Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 355 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 355 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6905 -- Serau/Saurau?, Georg Christian -- {'related_person': <Person: Serau/Saurau?, Georg Christian>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6906 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seraw, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Seraw, von END INPUT, ROW:6906
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seraw, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Seraw, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seraw, von, Carl Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 382 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 382 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6906 -- Seraw, von, Carl Ferdinand -- {'related_person': <Person: Seraw, von, Carl Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6907 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seraw, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Seraw, von END INPUT, ROW:6907
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seraw, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Seraw, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seraw, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6907 -- Seraw, von, NN -- {'related_person': <Person: Seraw, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6908 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serba
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serba
person_process_field_titel >>> t_tit = Baron
person_process_field_titel >>> t_list = ['Baron']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Edelknabe'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Edelknabe'], cH J, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serba, Franz>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Edelknabe']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Edelknabe
process_chunks >>>  Source Person Relation: 6908 -- Serba, Franz -- {'related_person': <Person: Serba, Franz>, 'related_institution': <Institution: OStA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Edelknabe>}

--------- Start of row | 6909 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serbelanj
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serbelanj
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serbelanj, Friedrich>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 387 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 387 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6909 -- Serbelanj, Friedrich -- {'related_person': <Person: Serbelanj, Friedrich>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6910 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 401 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 401 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6910 -- Serein, Franz -- {'related_person': <Person: Serein, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6911 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 406 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 406 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6911 -- Serein, Franz -- {'related_person': <Person: Serein, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6912 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 411 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 411 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6912 -- Serein, Franz -- {'related_person': <Person: Serein, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6913 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 416 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 416 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6913 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6914 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 421 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 421 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6914 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6915 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 426 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 426 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6915 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6916 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 431 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 431 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6916 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6917 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 436 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 436 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6917 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6918 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 441 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 441 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6918 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6919 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 446 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 446 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6919 -- Serein, Johann Carl -- {'related_person': <Person: Serein, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6920 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein, Johann Karl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 451 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 451 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6920 -- Serein, Johann Karl -- {'related_person': <Person: Serein, Johann Karl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6921 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein/Serényi?
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein/Serényi?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein/Serényi?, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 456 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 456 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6921 -- Serein/Serényi?, Johann Carl -- {'related_person': <Person: Serein/Serényi?, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6922 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serein/Serényi?
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serein/Serényi?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serein/Serényi?, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 461 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 461 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6922 -- Serein/Serényi?, Johann Carl -- {'related_person': <Person: Serein/Serényi?, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6923 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 466 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 466 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6923 -- Sereni, Franz -- {'related_person': <Person: Sereni, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6924 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 471 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 471 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6924 -- Sereni, Johann Carl -- {'related_person': <Person: Sereni, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6925 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 476 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 476 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6925 -- Sereni, Johann Carl -- {'related_person': <Person: Sereni, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6926 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni, oo Schaffgotsch
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Schaffgotsch
person_process_field_titel >>> t_tit = Gräfin; Gräfin
person_process_field_titel >>> t_list = ['Gräfin', 'Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = AW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: AW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: AW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'AW', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH AW, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: NEEDS REVIEW, Maria Franziska>}
chunk_get_nm_hst >>> c_H = AW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: AW (Kgin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (AW (Kgin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (AW (Kgin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 6926 -- NEEDS REVIEW, Maria Franziska -- {'related_person': <Person: NEEDS REVIEW, Maria Franziska>, 'related_institution': <Institution: Dummy Amt (AW (Kgin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 6927 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni, oo Schaffgotsch
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Schaffgotsch
person_process_field_titel >>> t_tit = Gräfin; Gräfin
person_process_field_titel >>> t_list = ['Gräfin', 'Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein', 'Heirat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein', 'Heirat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = AW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: AW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: AW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'AW', 'FUNKTION': ['Kammerfräulein', 'Heirat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein', 'Heirat'], cH AW, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: NEEDS REVIEW, Maria Franziska>}
chunk_get_nm_hst >>> c_H = AW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: AW (Kgin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (AW (Kgin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (AW (Kgin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein', 'Heirat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Heirat
process_chunks >>>  Source Person Relation: 6927 -- NEEDS REVIEW, Maria Franziska -- {'related_person': <Person: NEEDS REVIEW, Maria Franziska>, 'related_institution': <Institution: Dummy Amt (AW (Kgin.))>, 'relation_type': <PersonInstitutionRelation: Heirat>}

--------- Start of row | 6928 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni; Serény
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni; Serény
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni; Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 481 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 481 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6928 -- Sereni; Serény, Franz -- {'related_person': <Person: Sereni; Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6929 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni; Serény
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni; Serény
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni; Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 495 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 495 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6929 -- Sereni; Serény, Franz -- {'related_person': <Person: Sereni; Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6930 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereni; Serény
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereni; Serény
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereni; Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 500 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 500 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6930 -- Sereni; Serény, Franz -- {'related_person': <Person: Sereni; Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6931 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serenj
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serenj
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serenj, Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 505 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 505 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6931 -- Serenj, Anton -- {'related_person': <Person: Serenj, Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6932 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serenj
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serenj
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serenj, Franz>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6932 -- Serenj, Franz -- {'related_person': <Person: Serenj, Franz>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6933 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sereny
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sereny
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sereny, NN>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6933 -- Sereny, NN -- {'related_person': <Person: Sereny, NN>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6934 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Schereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 17), match='(Schereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 510 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 510 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 6934 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 6935 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 525 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 525 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6935 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6936 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 530 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 530 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6936 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6937 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 535 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 535 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6937 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6938 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 540 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 540 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6938 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6939 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 545 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 545 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6939 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6940 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serény (Sereni)
person_process_field_familienname >>> fam1: Serény
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sereni)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serény, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 550 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 550 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 6940 -- Serény, Franz -- {'related_person': <Person: Serény, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 6941 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serényi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serényi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serényi, Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 555 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 555 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6941 -- Serényi, Anton -- {'related_person': <Person: Serényi, Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6942 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serényi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serényi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serényi, Carl>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 516 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 516 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6942 -- Serényi, Carl -- {'related_person': <Person: Serényi, Carl>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6943 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serényi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serényi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serényi, Franz>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 565 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 565 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6943 -- Serényi, Franz -- {'related_person': <Person: Serényi, Franz>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6944 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serin
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 560 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 560 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6944 -- Serin, Johann -- {'related_person': <Person: Serin, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6945 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serin
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 575 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 575 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6945 -- Serin, Johann Carl -- {'related_person': <Person: Serin, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6946 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serin
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 580 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 580 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6946 -- Serin, Johann Carl -- {'related_person': <Person: Serin, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6947 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serin
person_process_field_titel >>> t_tit = von
person_process_field_titel >>> t_list = ['von']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> RenameFunctions.py >>> removing Ban from ents
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': [], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': [], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': [], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF [], cH Dummy Hofstaat, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Niclas>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F []
process_chunks >>>  Source Person Relation: 6947 -- Serin, Niclas -- {'related_person': <Person: Serin, Niclas>, 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>}

--------- Start of row | 6948 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serin
person_process_field_titel >>> t_tit = von
person_process_field_titel >>> t_list = ['von']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Niclas>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 290 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 290 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 6948 -- Serin, Niclas -- {'related_person': <Person: Serin, Niclas>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 6949 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serin (Serein)
person_process_field_familienname >>> fam1: Serin
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Serein)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serin, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 585 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 585 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6949 -- Serin, Peter -- {'related_person': <Person: Serin, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6950 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serini
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serini
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serini, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 596 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 596 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6950 -- Serini, Franz -- {'related_person': <Person: Serini, Franz>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6951 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seripi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seripi
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkaplan'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkaplan'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkaplan'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA  /  Hofkapelle
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA  ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA  ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofkaplan'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seripi, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 278 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 278 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkaplan']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkaplan
process_chunks >>>  Source Person Relation: 6951 -- Seripi, NN -- {'related_person': <Person: Seripi, NN>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkaplan>}

--------- Start of row | 6952 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serni
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serni, Philipp>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 601 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 601 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6952 -- Serni, Philipp -- {'related_person': <Person: Serni, Philipp>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6953 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Serseckh
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Serseckh
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Vorreiter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Vorreiter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = LW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: LW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: LW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'LW', 'FUNKTION': ['Vorreiter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Vorreiter
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Vorreiter'], cH LW, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Serseckh, Andree>}
chunk_get_nm_hst >>> c_H = LW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: LW
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (LW), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (LW)
chunk_create_relations >>> create relations called for c_F ['Vorreiter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Vorreiter
process_chunks >>>  Source Person Relation: 6953 -- Serseckh, Andree -- {'related_person': <Person: Serseckh, Andree>, 'related_institution': <Institution: OStA (LW)>, 'relation_type': <PersonInstitutionRelation: Vorreiter>}

--------- Start of row | 6954 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Servatius
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Servatius
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regierungsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regierungsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-RR / Ritterbank
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-RR ' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD [], cF ['Regierungsrat'], cH L, CA NÖ-RR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Servatius, Max>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 110 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 110 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regierungsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regierungsrat
process_chunks >>>  Source Person Relation: 6954 -- Servatius, Max -- {'related_person': <Person: Servatius, Max>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regierungsrat>}

--------- Start of row | 6955 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seßler
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seßler
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trompeter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trompeter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Trompeter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Hoffuttermeister
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Trompeter'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seßler, Ernst>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OStA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 284 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Set InstInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 284 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Deleted obsolete Institution OStA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OStA (L1 (Ks.)) is OStA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Trompeter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Trompeter
process_chunks >>>  Source Person Relation: 6955 -- Seßler, Ernst -- {'related_person': <Person: Seßler, Ernst>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Trompeter>}

--------- Start of row | 6956 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 611 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 611 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6956 -- Setschi, Peter -- {'related_person': <Person: Setschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6957 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 632 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 632 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6957 -- Setschi, Peter -- {'related_person': <Person: Setschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6958 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 637 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 637 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6958 -- Setschi, Peter -- {'related_person': <Person: Setschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6959 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 642 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 642 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6959 -- Setschi, Peter -- {'related_person': <Person: Setschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6960 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschi (Seltzschy)
person_process_field_familienname >>> fam1: Setschi
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 19), match='(Seltzschy)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 647 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 647 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6960 -- Setschi, Peter -- {'related_person': <Person: Setschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6961 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 6961 -- Setschy, Georg -- {'related_person': <Person: Setschy, Georg>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 6962 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 652 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 652 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6962 -- Setschy, Georg -- {'related_person': <Person: Setschy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6963 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 6963 -- Setschy, Georg -- {'related_person': <Person: Setschy, Georg>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 6964 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 660 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 660 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6964 -- Setschy, Georg -- {'related_person': <Person: Setschy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6965 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 668 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 668 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 6965 -- Setschy, Georg -- {'related_person': <Person: Setschy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 6966 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 6966 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 6967 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 673 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 673 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6967 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6968 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 681 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 681 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6968 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6969 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 686 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 686 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6969 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6970 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 691 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 691 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6970 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6971 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 696 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 696 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6971 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6972 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 701 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 701 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 6972 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 6973 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Setschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 706 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 706 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6973 -- Setschy, NN -- {'related_person': <Person: Setschy, NN>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6974 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy [Setschi]
person_process_field_familienname >>> fam1: Setschy
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='[Setschi]'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 711 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 711 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6974 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6975 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Setschy [Setschi]
person_process_field_familienname >>> fam1: Setschy
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='[Setschi]'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Setschy, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 716 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 716 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6975 -- Setschy, Peter -- {'related_person': <Person: Setschy, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6976 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seutz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seutz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kellerschreiber'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kellerschreiber'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofkontrollorsamt
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kellerschreiber'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seutz, Bartholomäus>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 8 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 8 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 8 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (J1 (Ehzg.)) is OMeA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kellerschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kellerschreiber
process_chunks >>>  Source Person Relation: 6976 -- Seutz, Bartholomäus -- {'related_person': <Person: Seutz, Bartholomäus>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kellerschreiber>}

--------- Start of row | 6977 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seutz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seutz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obsichthaber', 'Lichtkammer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obsichthaber', 'Lichtkammer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Obsichthaber', 'Lichtkammer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofkontrollorsamt
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Obsichthaber', 'Lichtkammer'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seutz, Bartholomäus>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 726 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 726 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (J1 (Ehzg.)) is OMeA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Obsichthaber', 'Lichtkammer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Obsichthaber
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Lichtkammer
process_chunks >>>  Source Person Relation: 6977 -- Seutz, Bartholomäus -- {'related_person': <Person: Seutz, Bartholomäus>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Lichtkammer>}

--------- Start of row | 6978 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seybaldt
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seybaldt
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Leiblakai'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Leiblakai'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Leiblakai'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Leiblakai'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seybaldt, Joseph>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Leiblakai']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Leiblakai
process_chunks >>>  Source Person Relation: 6978 -- Seybaldt, Joseph -- {'related_person': <Person: Seybaldt, Joseph>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Leiblakai>}

--------- Start of row | 6979 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seybiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seybiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = LW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: LW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: LW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'LW', 'FUNKTION': ['Raitdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HBH
helper_hsv_match_amt_with_funct >>> replaced amt 'HBH' with 'HBH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HBH' with 'HBH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HBH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HBH'
process_chunks >>> cD [], cF ['Raitdiener'], cH LW, CA HBH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seybiz, Christoph>}
chunk_get_nm_hst >>> c_H = LW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: LW
chunk_process_amt >>> c_A in if c_A true: HBH
chunk_process_amt >>> c_A was: HBH and amt after matching with amt index is: HBH, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HBH (LW), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HBH (LW)
chunk_create_relations >>> create relations called for c_F ['Raitdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Raitdiener
process_chunks >>>  Source Person Relation: 6979 -- Seybiz, Christoph -- {'related_person': <Person: Seybiz, Christoph>, 'related_institution': <Institution: HBH (LW)>, 'relation_type': <PersonInstitutionRelation: Raitdiener>}

--------- Start of row | 6980 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seyeriz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seyeriz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffizier
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seyeriz, Christoph Lucas>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 6980 -- Seyeriz, Christoph Lucas -- {'related_person': <Person: Seyeriz, Christoph Lucas>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 6981 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seyfried
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seyfried
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Konzipist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-GHKz
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-GHKz' with 'NÖ-GHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-GHKz' with 'NÖ-GHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-GHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-GHKz'
process_chunks >>> cD [], cF ['Konzipist'], cH L, CA NÖ-GHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seyfried, Melchior>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-GHKz
chunk_process_amt >>> amt NÖ-GHKz was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt NÖ-GHKz (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = NÖ-GHKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Konzipist']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Konzipist
process_chunks >>>  Source Person Relation: 6981 -- Seyfried, Melchior -- {'related_person': <Person: Seyfried, Melchior>, 'related_institution': <Institution: NÖ-GHKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Konzipist>}

--------- Start of row | 6982 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seywitz; Muggenthal
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seywitz; Muggenthal
person_process_field_titel >>> t_tit = NN; Edler
person_process_field_titel >>> t_list = ['NN', 'Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Raitrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raiträte
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitrat'], cH Dummy Hofstaat, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seywitz; Muggenthal, Christoph Lukas>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ BH (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ BH (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Raitrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Raitrat
process_chunks >>>  Source Person Relation: 6982 -- Seywitz; Muggenthal, Christoph Lukas -- {'related_person': <Person: Seywitz; Muggenthal, Christoph Lukas>, 'related_institution': <Institution: NÖ BH (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Raitrat>}

--------- Start of row | 6983 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Seywiz
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Seywiz
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Seywiz, Christoph Lukas>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 747 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 747 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 6983 -- Seywiz, Christoph Lukas -- {'related_person': <Person: Seywiz, Christoph Lukas>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 6984 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 721 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 721 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6984 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6985 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 764 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 764 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6985 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6986 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 769 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 769 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6986 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6987 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 774 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 774 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6987 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6988 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 779 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 779 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6988 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6989 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 784 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 784 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6989 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6990 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 789 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 789 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6990 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6991 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 794 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 794 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6991 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6992 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi (Setzi)
person_process_field_familienname >>> fam1: Sezi
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Setzi)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 799 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 799 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6992 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6993 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi (Setzi)
person_process_field_familienname >>> fam1: Sezi
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Setzi)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 804 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 804 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6993 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6994 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi (Setzy)
person_process_field_familienname >>> fam1: Sezi
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='(Setzy)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 809 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 809 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6994 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6995 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezi (Sezy)
person_process_field_familienname >>> fam1: Sezi
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 11), match='(Sezy)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 814 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 814 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6995 -- Sezi, Georg -- {'related_person': <Person: Sezi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6996 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sezy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sezy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sezy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 819 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 819 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6996 -- Sezy, Georg -- {'related_person': <Person: Sezy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6997 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sforza
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sforza
person_process_field_titel >>> t_tit = Don
person_process_field_titel >>> t_list = ['Don']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sforza, Federico>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 824 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 824 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6997 -- Sforza, Federico -- {'related_person': <Person: Sforza, Federico>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6998 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sforza
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sforza
person_process_field_titel >>> t_tit = Duca
person_process_field_titel >>> t_list = ['Duca']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sforza, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 829 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 829 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 6998 -- Sforza, Ferdinand -- {'related_person': <Person: Sforza, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 6999 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sheltschak
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sheltschak
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sheltschak, Abraham>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 759 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 759 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 6999 -- Sheltschak, Abraham -- {'related_person': <Person: Sheltschak, Abraham>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7000 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sibenbürger
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sibenbürger
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammerdienerin
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sibenbürger, Catharina>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7000 -- Sibenbürger, Catharina -- {'related_person': <Person: Sibenbürger, Catharina>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7001 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Siber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlist
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 622 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 622 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7001 -- Siber, Johann -- {'related_person': <Person: Siber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7002 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Siber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Schubschreiber'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ(?)
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?)' with 'NÖ'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?)' with 'NÖ'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ'
process_chunks >>> cD [], cF ['Schubschreiber'], cH L, CA NÖ
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ
chunk_process_amt >>> c_A was: NÖ and amt after matching with amt index is: NÖ (manuell), type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ (manuell) (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ (manuell) (L1 (Ks.)) from NÖ (manuell) (L1 (Ks.)), 30 to NÖ (manuell) (L1 (Ks.)), 29
db_deduplicate_aemter >>> Set InstInst Relation for NÖ (manuell) (L1 (Ks.)) from NÖ (manuell) (L1 (Ks.)), 30 to NÖ (manuell) (L1 (Ks.)), 29
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ (manuell) (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ (manuell) (L1 (Ks.)) is NÖ (manuell) (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ (manuell) (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ (manuell) (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Schubschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Schubschreiber
process_chunks >>>  Source Person Relation: 7002 -- Siber, Johann -- {'related_person': <Person: Siber, Johann>, 'related_institution': <Institution: NÖ (manuell) (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Schubschreiber>}

--------- Start of row | 7003 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sickingen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sickingen
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sickingen, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 7003 -- Sickingen, Franz -- {'related_person': <Person: Sickingen, Franz>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 7004 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sickingen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sickingen
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sickingen, Philipp Damian>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 570 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 570 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7004 -- Sickingen, Philipp Damian -- {'related_person': <Person: Sickingen, Philipp Damian>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7005 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sickofsky
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sickofsky
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sattelknecht'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sattelknecht'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sattelknecht'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Hoffuttermeister
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Sattelknecht'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sickofsky, Johann Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OStA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 627 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Set InstInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 627 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Deleted obsolete Institution OStA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OStA (L1 (Ks.)) is OStA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sattelknecht']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Sattelknecht
process_chunks >>>  Source Person Relation: 7005 -- Sickofsky, Johann Georg -- {'related_person': <Person: Sickofsky, Johann Georg>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sattelknecht>}

--------- Start of row | 7006 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Nimbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Nimbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 345 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 345 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7006 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7007 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Simbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 872 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 872 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7007 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7008 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Simbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 877 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 877 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7008 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7009 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Simbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 882 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 882 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7009 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7010 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Simbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 887 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 887 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7010 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7011 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbsche)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 22), match='(Simbsche)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 892 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 892 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7011 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7012 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbschen)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 23), match='(Simbschen)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 897 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 897 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7012 -- Siebenschön, Matthias -- {'related_person': <Person: Siebenschön, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7013 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbschen)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 23), match='(Simbschen)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist', 'Taxamtsgegenhandler'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist', 'Taxamtsgegenhandler'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist', 'Taxamtsgegenhandler'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist', 'Taxamtsgegenhandler'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 902 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 902 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist', 'Taxamtsgegenhandler']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Taxamtsgegenhandler
process_chunks >>>  Source Person Relation: 7013 -- Siebenschön, Matthias Ferdinand -- {'related_person': <Person: Siebenschön, Matthias Ferdinand>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Taxamtsgegenhandler>}

--------- Start of row | 7014 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbschen)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 23), match='(Simbschen)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-HBH-NÖ-BH'
process_chunks >>> cD [], cF ['Raitrat'], cH L, CA HK-HBH-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-HBH-NÖ-BH
chunk_process_amt >>> c_A was: HK-HBH-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 839 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 839 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitrat
process_chunks >>>  Source Person Relation: 7014 -- Siebenschön, Matthias Ferdinand -- {'related_person': <Person: Siebenschön, Matthias Ferdinand>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitrat>}

--------- Start of row | 7015 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siebenschön (Simbschen)
person_process_field_familienname >>> fam1: Siebenschön
person_process_field_familienname >>> fam2: <re.Match object; span=(12, 23), match='(Simbschen)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-HBH-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-HBH-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siebenschön, Matthias Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-HBH-NÖ-BH
chunk_process_amt >>> c_A was: HK-HBH-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 913 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 913 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7015 -- Siebenschön, Matthias Ferdinand -- {'related_person': <Person: Siebenschön, Matthias Ferdinand>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7016 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sieber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 849 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 849 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7016 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7017 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sieber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 923 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 923 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7017 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7018 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sieber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 928 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 928 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7018 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7019 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sieber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 933 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 933 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7019 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7020 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sieber
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 938 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 938 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7020 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7021 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 943 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 943 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7021 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7022 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 948 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 948 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7022 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7023 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 953 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 953 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7023 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7024 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 958 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 958 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7024 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7025 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 963 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 963 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7025 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7026 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 968 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 968 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7026 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7027 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Siber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Siber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Schubschreiber'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Schubschreiber'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 973 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 973 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Schubschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Schubschreiber
process_chunks >>>  Source Person Relation: 7027 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Schubschreiber>}

--------- Start of row | 7028 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Sieber/Syber?)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 22), match='(Sieber/Syber?)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 978 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 978 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7028 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7029 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Syber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Syber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 983 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 983 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7029 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7030 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Syber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Syber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 988 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 988 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7030 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7031 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Syber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Syber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Subschreiber'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Subschreiber'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Subschreiber'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Subschreiber'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 993 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 993 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Subschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Subschreiber
process_chunks >>>  Source Person Relation: 7031 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Subschreiber>}

--------- Start of row | 7032 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sieber (Syber)
person_process_field_familienname >>> fam1: Sieber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 14), match='(Syber)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Schubschreiber'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Schubschreiber'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R  /  Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R  ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R  ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Schubschreiber'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sieber, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 998 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 998 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Schubschreiber']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Schubschreiber
process_chunks >>>  Source Person Relation: 7032 -- Sieber, Johann -- {'related_person': <Person: Sieber, Johann>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Schubschreiber>}

--------- Start of row | 7033 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Signorini
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Signorini
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Signorini, Johann Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 834 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 834 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7033 -- Signorini, Johann Joachim -- {'related_person': <Person: Signorini, Johann Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7034 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sikota
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sikota
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sikota, Wenzl>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7034 -- Sikota, Wenzl -- {'related_person': <Person: Sikota, Wenzl>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7035 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silberschneider
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silberschneider
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silberschneider, Matthias>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7035 -- Silberschneider, Matthias -- {'related_person': <Person: Silberschneider, Matthias>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7036 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silberschneider
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silberschneider
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silberschneider, Matthias>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7036 -- Silberschneider, Matthias -- {'related_person': <Person: Silberschneider, Matthias>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7037 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sillnipoffsky [Scuipoffsky]
person_process_field_familienname >>> fam1: Sillnipoffsky
person_process_field_familienname >>> fam2: <re.Match object; span=(14, 27), match='[Scuipoffsky]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sillnipoffsky, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7037 -- Sillnipoffsky, NN -- {'related_person': <Person: Sillnipoffsky, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7038 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvia
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7038 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7039 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvia
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7039 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7040 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvia
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7040 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7041 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvia
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7041 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7042 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvia
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7042 -- Silvia, NN -- {'related_person': <Person: Silvia, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7043 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia (Siliua)
person_process_field_familienname >>> fam1: Silvia
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Siliua)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7043 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7044 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia (Syldia)
person_process_field_familienname >>> fam1: Silvia
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Syldia)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7044 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7045 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvia [Bresciani]
person_process_field_familienname >>> fam1: Silvia
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 18), match='[Bresciani]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener', 'Kammerherr'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener', 'Kammerherr'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener', 'Kammerherr'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener', 'Kammerherr'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvia, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener', 'Kammerherr']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerherr
process_chunks >>>  Source Person Relation: 7045 -- Silvia, Johann -- {'related_person': <Person: Silvia, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerherr>}

--------- Start of row | 7046 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Silvio
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Silvio
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdiener'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Silvio, Johann>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7046 -- Silvio, Johann -- {'related_person': <Person: Silvio, Johann>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7047 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbsche
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbsche
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 907 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 907 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 907 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7047 -- Simbsche, Matthias -- {'related_person': <Person: Simbsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7048 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbsche
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbsche
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1055 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1055 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7048 -- Simbsche, Matthias -- {'related_person': <Person: Simbsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7049 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbsche
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbsche
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1060 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1060 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7049 -- Simbsche, Matthias -- {'related_person': <Person: Simbsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7050 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbsche
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbsche
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1065 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1065 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7050 -- Simbsche, Matthias -- {'related_person': <Person: Simbsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7051 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbsche
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbsche
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlei
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1070 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1070 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7051 -- Simbsche, Matthias -- {'related_person': <Person: Simbsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7052 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbschen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbschen
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Raitrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raiträte
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitrat'], cH Dummy Hofstaat, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbschen, Matthäus Fortunat>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ BH (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ BH (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Raitrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitrat
process_chunks >>>  Source Person Relation: 7052 -- Simbschen, Matthäus Fortunat -- {'related_person': <Person: Simbschen, Matthäus Fortunat>, 'related_institution': <Institution: NÖ BH (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Raitrat>}

--------- Start of row | 7053 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbschen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbschen
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH / Raitoffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH ' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH Dummy Hofstaat, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbschen, Matthäus Fortunat>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ BH (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ BH (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7053 -- Simbschen, Matthäus Fortunat -- {'related_person': <Person: Simbschen, Matthäus Fortunat>, 'related_institution': <Institution: NÖ BH (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7054 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbschen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbschen
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Registrator', 'Taxamtsgegenhandler'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Registrator', 'Taxamtsgegenhandler'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Registrator', 'Taxamtsgegenhandler'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Registratur
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Registrator', 'Taxamtsgegenhandler']'
process_chunks >>> cD [], cF ['Registrator', 'Taxamtsgegenhandler'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbschen, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1075 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1075 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Registrator', 'Taxamtsgegenhandler']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Registrator
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Taxamtsgegenhandler
process_chunks >>>  Source Person Relation: 7054 -- Simbschen, Matthias -- {'related_person': <Person: Simbschen, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Taxamtsgegenhandler>}

--------- Start of row | 7055 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbscho [Schimpff?]
person_process_field_familienname >>> fam1: Simbscho
person_process_field_familienname >>> fam2: <re.Match object; span=(9, 20), match='[Schimpff?]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbscho, Mathias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1084 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1084 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1084 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7055 -- Simbscho, Mathias -- {'related_person': <Person: Simbscho, Mathias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7056 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simbse
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simbse
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK / Kanzlisten
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK ' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simbse, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1090 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1090 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7056 -- Simbse, Matthias -- {'related_person': <Person: Simbse, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7057 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simon
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simon
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Oberkammerfourier'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simon, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1008 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1008 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Oberkammerfourier']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Oberkammerfourier
process_chunks >>>  Source Person Relation: 7057 -- Simon, Johann -- {'related_person': <Person: Simon, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Oberkammerfourier>}

--------- Start of row | 7058 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simon
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simon
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Unterkammerfourier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Unterkammerfourier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = F3(?)
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: F3(?)
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: F3(?)
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'F3(?)', 'FUNKTION': ['Unterkammerfourier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Unterkammerfourier'], cH F3(?), CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simon, Johann Wilhelm>}
chunk_get_nm_hst >>> c_H = F3(?)
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: F3
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (F3)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (F3)
chunk_create_relations >>> create relations called for c_F ['Unterkammerfourier']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Unterkammerfourier
process_chunks >>>  Source Person Relation: 7058 -- Simon, Johann Wilhelm -- {'related_person': <Person: Simon, Johann Wilhelm>, 'related_institution': <Institution: Dummy Amt (F3)>, 'relation_type': <PersonInstitutionRelation: Unterkammerfourier>}

--------- Start of row | 7059 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simon
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simon
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Saaltürhüter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Saaltürhüter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Saaltürhüter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Saaltürhüter'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simon, Wenzel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 606 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 606 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Saaltürhüter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Saaltürhüter
process_chunks >>>  Source Person Relation: 7059 -- Simon, Wenzel -- {'related_person': <Person: Simon, Wenzel>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Saaltürhüter>}

--------- Start of row | 7060 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simon
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simon
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Oberkammerfourier'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simon, NN>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1100 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1100 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Oberkammerfourier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Oberkammerfourier
process_chunks >>>  Source Person Relation: 7060 -- Simon, NN -- {'related_person': <Person: Simon, NN>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Oberkammerfourier>}

--------- Start of row | 7061 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simoni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simoni
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simoni, Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7061 -- Simoni, Anton -- {'related_person': <Person: Simoni, Anton>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7062 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simoni
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Simoni
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simoni, Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7062 -- Simoni, Anton -- {'related_person': <Person: Simoni, Anton>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7063 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Simsche (Semische)
person_process_field_familienname >>> fam1: Simsche
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Semische)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kanzlist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kanzlist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Kanzlist'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Simsche, Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1095 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1095 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kanzlist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kanzlist
process_chunks >>>  Source Person Relation: 7063 -- Simsche, Matthias -- {'related_person': <Person: Simsche, Matthias>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kanzlist>}

--------- Start of row | 7064 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sincigl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sincigl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sincigl, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7064 -- Sincigl, NN -- {'related_person': <Person: Sincigl, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7065 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sincigl, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sincigl, von END INPUT, ROW:7065
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sincigl, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Sincigl, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sincigl, von, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7065 -- Sincigl, von, NN -- {'related_person': <Person: Sincigl, von, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7066 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sincigl(in)
person_process_field_familienname >>> fam1: Sincigl(in)
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 11), match='(in)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sincigl(in), NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7066 -- Sincigl(in), NN -- {'related_person': <Person: Sincigl(in), NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7067 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sincigl(in) (Hinciglien)
person_process_field_familienname >>> fam1: Sincigl(in)
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 11), match='(in)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Hoffräulein', 'Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hoffräulein', 'Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sincigl(in), NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Hoffräulein', 'Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hoffräulein
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7067 -- Sincigl(in), NN -- {'related_person': <Person: Sincigl(in), NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7068 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinciglin
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinciglin
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammerfräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinciglin, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7068 -- Sinciglin, NN -- {'related_person': <Person: Sinciglin, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7069 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sing
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sing
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Oberkammerfourier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Oberkammerfourier'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sing, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1115 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1115 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Oberkammerfourier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Oberkammerfourier
process_chunks >>>  Source Person Relation: 7069 -- Sing, Johann -- {'related_person': <Person: Sing, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Oberkammerfourier>}

--------- Start of row | 7070 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Singer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Singer
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Singer, Ferdinand>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7070 -- Singer, Ferdinand -- {'related_person': <Person: Singer, Ferdinand>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7071 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Singer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Singer
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hartschier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Hartschier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Hartschierenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hartschier'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Singer, Ferdinand>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Hartschier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hartschier
process_chunks >>>  Source Person Relation: 7071 -- Singer, Ferdinand -- {'related_person': <Person: Singer, Ferdinand>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Hartschier>}

--------- Start of row | 7072 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sini
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sini
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hauptmann'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hauptmann'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hauptmann'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = Wien, Favorita
helper_hsv_match_amt_with_funct >>> replaced amt 'Wien, Favorita' with 'Wien, Favorita'
helper_hsv_match_amt_with_funct >>> replaced amt 'Wien, Favorita' with 'Wien, Favorita'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = Wien, Favorita
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Wien, Favorita'
process_chunks >>> cD [], cF ['Hauptmann'], cH L, CA Wien, Favorita
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sini, Hieronimus Ignaz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Wien, Favorita
chunk_process_amt >>> c_A was: Wien, Favorita and amt after matching with amt index is: Favorita, Residenz, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent Favorita, Residenz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Favorita, Residenz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hauptmann']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hauptmann
process_chunks >>>  Source Person Relation: 7072 -- Sini, Hieronimus Ignaz -- {'related_person': <Person: Sini, Hieronimus Ignaz>, 'related_institution': <Institution: Favorita, Residenz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hauptmann>}

--------- Start of row | 7073 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinig, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sinig, von END INPUT, ROW:7073
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinig, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Sinig, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinig, von, Georg Constantin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 7073 -- Sinig, von, Georg Constantin -- {'related_person': <Person: Sinig, von, Georg Constantin>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 7074 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinnich
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinnich
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1692-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['supernumerärer Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1692-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['supernumerärer Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1692-00-00'], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['supernumerärer Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1692-00-00'], cF ['supernumerärer Regimentsrat'], cH Dummy Hofstaat, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1692-00-00, new: 1692<1692-06-30>
chunk_process_datum >>> rel, chunk sdw: 1692<1692-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinnich, Georg constantin>, 'start_date_written': '1692<1692-06-30>'}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['supernumerärer Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = supernumerärer Regimentsrat
process_chunks >>>  Source Person Relation: 7074 -- Sinnich, Georg constantin -- {'related_person': <Person: Sinnich, Georg constantin>, 'start_date_written': '1692<1692-06-30>', 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: supernumerärer Regimentsrat>}

--------- Start of row | 7075 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinnich
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinnich
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> Chunk AMT = NÖ Stände
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obereinnehmer'], 'AMT': 'NÖ Stände'}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obereinnehmer'], 'AMT': 'NÖ Stände'}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Obereinnehmer'], 'AMT': 'NÖ Stände'}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ Stände'
process_chunks >>> cD [], cF ['Obereinnehmer'], cH Dummy Hofstaat, CA NÖ Stände
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinnich, Georg constantin>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ Stände
chunk_process_amt >>> amt NÖ Stände was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt NÖ Stände (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ Stände (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Obereinnehmer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Obereinnehmer
process_chunks >>>  Source Person Relation: 7075 -- Sinnich, Georg constantin -- {'related_person': <Person: Sinnich, Georg constantin>, 'related_institution': <Institution: NÖ Stände (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Obereinnehmer>}

--------- Start of row | 7076 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinnich, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sinnich, von END INPUT, ROW:7076
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinnich, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Sinnich, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Verordneter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Verordneter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Verordneter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ / Verordnete
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ'
process_chunks >>> cD [], cF ['Verordneter'], cH Dummy Hofstaat, CA NÖ
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinnich, von, Georg Konstantin>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ
chunk_process_amt >>> c_A was: NÖ and amt after matching with amt index is: NÖ (manuell), type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ (manuell) (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ (manuell) (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Verordneter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Verordneter
process_chunks >>>  Source Person Relation: 7076 -- Sinnich, von, Georg Konstantin -- {'related_person': <Person: Sinnich, von, Georg Konstantin>, 'related_institution': <Institution: NÖ (manuell) (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Verordneter>}

--------- Start of row | 7077 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinnich, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sinnich, von END INPUT, ROW:7077
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinnich, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Sinnich, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Mundschenk'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Mundschenk'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Mundschenk'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinnich, von, Georg Konstantin>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1110 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1110 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Mundschenk']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Mundschenk
process_chunks >>>  Source Person Relation: 7077 -- Sinnich, von, Georg Konstantin -- {'related_person': <Person: Sinnich, von, Georg Konstantin>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Mundschenk>}

--------- Start of row | 7078 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinnich, von
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sinnich, von END INPUT, ROW:7078
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinnich, von
person_process_field_familienname >>> WHAT TO DO WITH THESE NAME: Sinnich, von
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Verordneter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Verordneter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Verordneter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG? / Verordnete
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG?
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG?'
process_chunks >>> cD [], cF ['Verordneter'], cH Dummy Hofstaat, CA NÖ-LG?
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinnich, von, Georg Konstantin>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ-LG?
chunk_process_amt >>> amt NÖ-LG? was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt NÖ-LG? (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ-LG? (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Verordneter']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Verordneter
process_chunks >>>  Source Person Relation: 7078 -- Sinnich, von, Georg Konstantin -- {'related_person': <Person: Sinnich, von, Georg Konstantin>, 'related_institution': <Institution: NÖ-LG? (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Verordneter>}

--------- Start of row | 7079 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD ['1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>'], cF ['Kämmerer'], cH L, CA OKäA
helper_hsv_post_process_dates >>> inner date: <1679-06-09 - 1679-06-11>
helper_hsv_post_process_dates >>> new_i_date: <1679-06-09 - 1679-06-11>
helper_hsv_post_process_dates >>> old: 1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>, new: 1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>
chunk_process_datum >>> rel, chunk sdw: 1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Adolph Michael>, 'start_date_written': '1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1148 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1148 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7079 -- Sinzendorf, Adolph Michael -- {'related_person': <Person: Sinzendorf, Adolph Michael>, 'start_date_written': '1679-06-09/1679-06-11<1679-06-09 - 1679-06-11>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7080 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(2) = [{'DATUM': ['1665-05-20', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}, {'DATUM': ['1675-00-00', 'bis 1677<1677-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1665-05-20', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1675-00-00', 'bis 1677<1677-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 2, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = L; J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h:  J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1665-05-20', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1675-00-00', 'bis 1677<1677-06-30>'], 'HOFSTAAT': 'J', 'FUNKTION': ['Regimentsrat', 'Regierungsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA; NÖ-RR
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt ' NÖ-RR' with 'NÖ-RR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-RR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-RR'
process_chunks >>> cD ['1665-05-20', 'bis 1704<1704-06-30>'], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
helper_hsv_post_process_dates >>> old: 1665-05-20, new: 1665-05-20<1665-05-20>
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1665-05-20<1665-05-20>
chunk_process_datum >>> rel, chunk edw: 1665-05-20<1665-05-20>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, August >, 'start_date_written': '1665-05-20<1665-05-20>', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1186 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1186 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7080 -- Sinzendorf, August  -- {'related_person': <Person: Sinzendorf, August >, 'start_date_written': '1665-05-20<1665-05-20>', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}
process_chunks >>> cD ['1675-00-00', 'bis 1677<1677-06-30>'], cF ['Regimentsrat', 'Regierungsrat'], cH J, CA NÖ-RR
helper_hsv_post_process_dates >>> old: 1675-00-00, new: 1675<1675-06-30>
helper_hsv_post_process_dates >>> inner date: <1677-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1677-06-30>
helper_hsv_post_process_dates >>> old: bis 1677<1677-06-30>, new: bis 1677<1677-06-30>
chunk_process_datum >>> rel, chunk sdw: 1675<1675-06-30>
chunk_process_datum >>> rel, chunk edw: 1675<1675-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, August >, 'start_date_written': '1675<1675-06-30>', 'end_date_written': 'bis 1677<1677-06-30>'}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: NÖ-RR
chunk_process_amt >>> c_A was: NÖ-RR and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (J1 (Ehzg.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat', 'Regierungsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regierungsrat
process_chunks >>>  Source Person Relation: 7080 -- Sinzendorf, August  -- {'related_person': <Person: Sinzendorf, August >, 'start_date_written': '1675<1675-06-30>', 'end_date_written': 'bis 1677<1677-06-30>', 'related_institution': <Institution: NÖ Reg. (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Regierungsrat>}

--------- Start of row | 7081 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(3) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer wirkl.'], 'AMT': None}, {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}, {'DATUM': ['1669-00-00', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer wirkl.'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	2: chunk: {'DATUM': ['1669-00-00', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 3, len Ämter-Spalte: 3
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer wirkl.'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1669-00-00', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR; OKäA; RHR / Herrenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> replaced amt ' OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt ' RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Kämmerer wirkl.'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Carl Ludwig >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 591 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 591 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kämmerer wirkl.
process_chunks >>>  Source Person Relation: 7081 -- Sinzendorf, Carl Ludwig  -- {'related_person': <Person: Sinzendorf, Carl Ludwig >, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer wirkl.>}
process_chunks >>> cD [], cF ['Geh. Rat, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Carl Ludwig >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1191 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1191 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 7081 -- Sinzendorf, Carl Ludwig  -- {'related_person': <Person: Sinzendorf, Carl Ludwig >, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}
process_chunks >>> cD ['1669-00-00', 'bis 1704<1704-06-30>'], cF ['Reichshofrat'], cH L, CA RHR
helper_hsv_post_process_dates >>> old: 1669-00-00, new: 1669<1669-06-30>
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1669<1669-06-30>
chunk_process_datum >>> rel, chunk edw: 1669<1669-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Carl Ludwig >, 'start_date_written': '1669<1669-06-30>', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7081 -- Sinzendorf, Carl Ludwig  -- {'related_person': <Person: Sinzendorf, Carl Ludwig >, 'start_date_written': '1669<1669-06-30>', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7082 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Kavalier, 1670-02-00, Kämmerer, 1672/73-00-00, 1676-00-00)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7082, Kavalier (1670-02-00); Kämmerer (101 \ 105 \ 108 \ 150.) , (1672/73-00-00 bis 1676-00-00), [{'start': 0, 'end': 8, 'token_start': 0, 'token_end': 0, 'label': 'FUNKTION'}, {'start': 10, 'end': 20, 'token_start': 2, 'token_end': 6, 'label': 'DATUM'}, {'start': 23, 'end': 31, 'token_start': 9, 'token_end': 9, 'label': 'FUNKTION'}, {'start': 59, 'end': 72, 'token_start': 21, 'token_end': 27, 'label': 'DATUM'}, {'start': 77, 'end': 87, 'token_start': 29, 'token_end': 33, 'label': 'DATUM'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Kavalier, 1670-02-00, Kämmerer, 1672/73-00-00, 1676-00-00]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Kavalier, 1670-02-00, Kämmerer, 1672/73-00-00, 1676-00-00)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(2) = [{'DATUM': ['1670-02-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kavalier'], 'AMT': None}, {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1676<1676-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1670-02-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kavalier'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1676<1676-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 2, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = EG; L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h:  L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1670-02-00'], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kavalier'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1676<1676-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kavalier); OKäA
helper_hsv_match_amt_with_funct >>> replaced amt '(Kavalier)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kavalier)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> replaced amt ' OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD ['1670-02-00'], cF ['Kavalier'], cH EG, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1670-02-00, new: 1670-02-00<1670-02-00>
chunk_process_datum >>> rel, chunk sdw: 1670-02-00<1670-02-00>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Ferdinand>, 'start_date_written': '1670-02-00<1670-02-00>'}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kavalier']
parse_iso_date >>> APIS: Could not interpret date: <class 'ValueError'>
parse_date >>>  APIS: Could not parse date: ' 1670-02-00<1670-02-00> ' due to error ('Invalid iso date: ', '1670-02-00'): 
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kavalier
process_chunks >>>  Source Person Relation: 7082 -- Sinzendorf, Ferdinand -- {'related_person': <Person: Sinzendorf, Ferdinand>, 'start_date_written': '1670-02-00<1670-02-00>', 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kavalier>}
process_chunks >>> cD ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1676<1676-06-30>'], cF ['Kämmerer'], cH L, CA OKäA
helper_hsv_post_process_dates >>> inner date: <1672-06-30 - 73-00-00>
helper_hsv_post_process_dates >>> new_i_date: <1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> old: 1672/73-00-00<1672-06-30 - 73-00-00>, new: 1672/73-00-00<1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> inner date: <1676-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1676-06-30>
helper_hsv_post_process_dates >>> old: bis 1676<1676-06-30>, new: bis 1676<1676-06-30>
chunk_process_datum >>> rel, chunk sdw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>> rel, chunk edw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Ferdinand>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1676<1676-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1205 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1205 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7082 -- Sinzendorf, Ferdinand -- {'related_person': <Person: Sinzendorf, Ferdinand>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1676<1676-06-30>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7083 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Hofkammerpräsident, 1657, 1679, Beisitzer, Landrecht, 1672/73-00-00, 1675-00-00, Geh. Rat, wirkl., 1672/73-00-00, 1678-00-00)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7083, Hofkammerpräsident (1657 bis 1679, abgesetzt); Beisitzer, Landrecht, Herrenstand (3.) , (1672/73-00-00 bis 1675-00-00); Geh. Rat, wirkl. (6 \ 7 \ 8 \ 9 .) , (1672/73-00-00 bis 1678-00-00), [{'start': 0, 'end': 18, 'token_start': 0, 'token_end': 0, 'label': 'FUNKTION'}, {'start': 20, 'end': 24, 'token_start': 2, 'token_end': 2, 'label': 'DATUM'}, {'start': 29, 'end': 33, 'token_start': 4, 'token_end': 4, 'label': 'DATUM'}, {'start': 47, 'end': 67, 'token_start': 9, 'token_end': 11, 'label': 'FUNKTION'}, {'start': 88, 'end': 101, 'token_start': 19, 'token_end': 25, 'label': 'DATUM'}, {'start': 106, 'end': 116, 'token_start': 27, 'token_end': 31, 'label': 'DATUM'}, {'start': 119, 'end': 135, 'token_start': 34, 'token_end': 39, 'label': 'FUNKTION'}, {'start': 156, 'end': 169, 'token_start': 52, 'token_end': 58, 'label': 'DATUM'}, {'start': 174, 'end': 184, 'token_start': 60, 'token_end': 64, 'label': 'DATUM'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Hofkammerpräsident, 1657, 1679, Beisitzer, Landrecht, 1672/73-00-00, 1675-00-00, Geh. Rat, wirkl., 1672/73-00-00, 1678-00-00]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Hofkammerpräsident, 1657, 1679, Beisitzer, Landrecht, 1672/73-00-00, 1675-00-00, Geh. Rat, wirkl., 1672/73-00-00, 1678-00-00)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(3) = [{'DATUM': ['1657', 'bis 1679<1679-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerpräsident'], 'AMT': None}, {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1675<1675-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Beisitzer, Landrecht'], 'AMT': None}, {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1678<1678-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1657', 'bis 1679<1679-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerpräsident'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1675<1675-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Beisitzer, Landrecht'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	2: chunk: {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1678<1678-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 3, len Ämter-Spalte: 3
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1657', 'bis 1679<1679-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerpräsident'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1675<1675-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Beisitzer, Landrecht'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1678<1678-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR; HK; NÖ-LG / Landrechtsbeisitzer, Herrenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> replaced amt ' HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> replaced amt ' NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> cD ['1657', 'bis 1679<1679-06-30>'], cF ['Hofkammerpräsident'], cH L, CA GR
helper_hsv_post_process_dates >>> old: 1657, new: 1657<1657-06-30>
helper_hsv_post_process_dates >>> inner date: <1679-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1679-06-30>
helper_hsv_post_process_dates >>> old: bis 1679<1679-06-30>, new: bis 1679<1679-06-30>
chunk_process_datum >>> rel, chunk sdw: 1657<1657-06-30>
chunk_process_datum >>> rel, chunk edw: 1657<1657-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1657<1657-06-30>', 'end_date_written': 'bis 1679<1679-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1202 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1202 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerpräsident']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofkammerpräsident
process_chunks >>>  Source Person Relation: 7083 -- Sinzendorf, Georg Ludwig -- {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1657<1657-06-30>', 'end_date_written': 'bis 1679<1679-06-30>', 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerpräsident>}
process_chunks >>> cD ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1675<1675-06-30>'], cF ['Beisitzer, Landrecht'], cH L, CA HK
helper_hsv_post_process_dates >>> inner date: <1672-06-30 - 73-00-00>
helper_hsv_post_process_dates >>> new_i_date: <1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> old: 1672/73-00-00<1672-06-30 - 73-00-00>, new: 1672/73-00-00<1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> inner date: <1675-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1675-06-30>
helper_hsv_post_process_dates >>> old: bis 1675<1675-06-30>, new: bis 1675<1675-06-30>
chunk_process_datum >>> rel, chunk sdw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>> rel, chunk edw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1675<1675-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1126 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1126 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Beisitzer, Landrecht']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Beisitzer, Landrecht
process_chunks >>>  Source Person Relation: 7083 -- Sinzendorf, Georg Ludwig -- {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1675<1675-06-30>', 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Beisitzer, Landrecht>}
process_chunks >>> cD ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis 1678<1678-06-30>'], cF ['Geh. Rat, wirkl.'], cH L, CA NÖ-LG
helper_hsv_post_process_dates >>> inner date: <1672-06-30 - 73-00-00>
helper_hsv_post_process_dates >>> new_i_date: <1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> old: 1672/73-00-00<1672-06-30 - 73-00-00>, new: 1672/73-00-00<1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> inner date: <1678-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1678-06-30>
helper_hsv_post_process_dates >>> old: bis 1678<1678-06-30>, new: bis 1678<1678-06-30>
chunk_process_datum >>> rel, chunk sdw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>> rel, chunk edw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1678<1678-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 7083 -- Sinzendorf, Georg Ludwig -- {'related_person': <Person: Sinzendorf, Georg Ludwig>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis 1678<1678-06-30>', 'related_institution': <Institution: NÖ Landmarsch. Gericht (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}

--------- Start of row | 7084 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced )) with: ) )
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(3) = [{'DATUM': ['1657-06-18', 'bis 1665<1665-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler'], 'AMT': None}, {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}, {'DATUM': ['1685-05-30/('], 'HOFSTAAT': None, 'FUNKTION': [], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1657-06-18', 'bis 1665<1665-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	2: chunk: {'DATUM': ['1685-05-30/('], 'HOFSTAAT': None, 'FUNKTION': [], 'AMT': None}
process_chunks >>> len_doc_chunks: 3, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1657-06-18', 'bis 1665<1665-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkanzler'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1685-05-30/('], 'HOFSTAAT': 'L', 'FUNKTION': [], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = Ö-HKz; OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'Ö-HKz' with 'Ö-HKz'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Ö-HKz'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
process_chunks >>> cD ['1657-06-18', 'bis 1665<1665-06-30>'], cF ['Hofkanzler'], cH L, CA Ö-HKz
helper_hsv_post_process_dates >>> old: 1657-06-18, new: 1657-06-18<1657-06-18>
helper_hsv_post_process_dates >>> inner date: <1665-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1665-06-30>
helper_hsv_post_process_dates >>> old: bis 1665<1665-06-30>, new: bis 1665<1665-06-30>
chunk_process_datum >>> rel, chunk sdw: 1657-06-18<1657-06-18>
chunk_process_datum >>> rel, chunk edw: 1657-06-18<1657-06-18>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Johann Joachim >, 'start_date_written': '1657-06-18<1657-06-18>', 'end_date_written': 'bis 1665<1665-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Ö-HKz
chunk_process_amt >>> c_A was: Ö-HKz and amt after matching with amt index is: Ö HKz, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ö HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ö HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkanzler']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofkanzler
process_chunks >>>  Source Person Relation: 7084 -- Sinzendorf, Johann Joachim  -- {'related_person': <Person: Sinzendorf, Johann Joachim >, 'start_date_written': '1657-06-18<1657-06-18>', 'end_date_written': 'bis 1665<1665-06-30>', 'related_institution': <Institution: Ö HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkanzler>}
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Johann Joachim >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7084 -- Sinzendorf, Johann Joachim  -- {'related_person': <Person: Sinzendorf, Johann Joachim >, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}
process_chunks >>> cD ['1685-05-30/('], cF [], cH L, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1685-05-30/(, new: 1685-05-30/(
chunk_process_datum >>> rel, chunk sdw: 1685-05-30/(
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Johann Joachim >, 'start_date_written': '1685-05-30/('}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F []
process_chunks >>>  Source Person Relation: 7084 -- Sinzendorf, Johann Joachim  -- {'related_person': <Person: Sinzendorf, Johann Joachim >, 'start_date_written': '1685-05-30/(', 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>}

--------- Start of row | 7085 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(2) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberstfalkenmeister'], 'AMT': None}, {'DATUM': ['1701-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Oberstjägermeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Oberstfalkenmeister'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1701-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Oberstjägermeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 2, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Oberstfalkenmeister'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1701-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Oberstjägermeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OFaA; OJäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OFaA' with 'OFaA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OFaA' with 'OFaA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OFaA
helper_hsv_match_amt_with_funct >>> replaced amt ' OJäA' with 'OJäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OJäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OFaA'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OJäA'
process_chunks >>> cD [], cF ['Oberstfalkenmeister'], cH L, CA OFaA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Johann Weickhard Michael Wenzel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OFaA
chunk_process_amt >>> c_A was: OFaA and amt after matching with amt index is: OFaA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OFaA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OFaA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Oberstfalkenmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Oberstfalkenmeister
process_chunks >>>  Source Person Relation: 7085 -- Sinzendorf, Johann Weickhard Michael Wenzel -- {'related_person': <Person: Sinzendorf, Johann Weickhard Michael Wenzel>, 'related_institution': <Institution: OFaA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Oberstfalkenmeister>}
process_chunks >>> cD ['1701-00-00'], cF ['Oberstjägermeister'], cH L, CA OJäA
helper_hsv_post_process_dates >>> old: 1701-00-00, new: 1701<1701-06-30>
chunk_process_datum >>> rel, chunk sdw: 1701<1701-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Johann Weickhard Michael Wenzel>, 'start_date_written': '1701<1701-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OJäA
chunk_process_amt >>> amt OJäA was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt OJäA (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = OJäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Oberstjägermeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Oberstjägermeister
process_chunks >>>  Source Person Relation: 7085 -- Sinzendorf, Johann Weickhard Michael Wenzel -- {'related_person': <Person: Sinzendorf, Johann Weickhard Michael Wenzel>, 'start_date_written': '1701<1701-06-30>', 'related_institution': <Institution: OJäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Oberstjägermeister>}

--------- Start of row | 7086 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1699-01-01', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1699-01-01', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = AW
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: AW
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: AW
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1699-01-01', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'AW', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1699-01-01', 'bis 1704<1704-06-30>'], cF ['Kammerfräulein'], cH AW, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1699-01-01, new: 1699-01-01<1699-01-01>
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1699-01-01<1699-01-01>
chunk_process_datum >>> rel, chunk edw: 1699-01-01<1699-01-01>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Maria Maximiliana >, 'start_date_written': '1699-01-01<1699-01-01>', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = AW
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: AW (Kgin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (AW (Kgin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (AW (Kgin.))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7086 -- Sinzendorf, Maria Maximiliana  -- {'related_person': <Person: Sinzendorf, Maria Maximiliana >, 'start_date_written': '1699-01-01<1699-01-01>', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: Dummy Amt (AW (Kgin.))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7087 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Kämmerer, 1686-11-15/(, 1704-00-00, Abgesandter, ao, 1699, Obersthofkanzler, K, Envoye, 1701-00-00, Abgesandter, 1704-00-00, Geh. Rat, 1704-00-00)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7087, Kämmerer (34 \ 45 \ 281 \ 851 \ 1060.) , (1686-11-15/(?) bis 1704-00-00); Abgesandter, ao. in Paris (1699) u. späterer Obersthofkanzler K; Envoye in Frankreich (1701-00-00); Abgesandter, ksl., am untern Rhein (1704-00-00); Geh. Rat (118.) , (1704-00-00), [{'start': 0, 'end': 8, 'token_start': 0, 'token_end': 0, 'label': 'FUNKTION'}, {'start': 41, 'end': 51, 'token_start': 14, 'token_end': 18, 'label': 'DATUM'}, {'start': 60, 'end': 70, 'token_start': 24, 'token_end': 28, 'label': 'DATUM'}, {'start': 73, 'end': 88, 'token_start': 31, 'token_end': 33, 'label': 'FUNKTION'}, {'start': 100, 'end': 104, 'token_start': 38, 'token_end': 38, 'label': 'DATUM'}, {'start': 118, 'end': 134, 'token_start': 42, 'token_end': 42, 'label': 'FUNKTION'}, {'start': 135, 'end': 136, 'token_start': 43, 'token_end': 43, 'label': 'HOFSTAAT'}, {'start': 138, 'end': 144, 'token_start': 45, 'token_end': 45, 'label': 'FUNKTION'}, {'start': 160, 'end': 170, 'token_start': 49, 'token_end': 53, 'label': 'DATUM'}, {'start': 173, 'end': 184, 'token_start': 56, 'token_end': 56, 'label': 'FUNKTION'}, {'start': 209, 'end': 219, 'token_start': 65, 'token_end': 69, 'label': 'DATUM'}, {'start': 222, 'end': 230, 'token_start': 72, 'token_end': 74, 'label': 'FUNKTION'}, {'start': 240, 'end': 250, 'token_start': 80, 'token_end': 84, 'label': 'DATUM'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Kämmerer, 1686-11-15, 1704-00-00, Abgesandter, ao, 1699, Obersthofkanzler, K, Envoye, 1701-00-00, Abgesandter, 1704-00-00, Geh. Rat, 1704-00-00]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Kämmerer, 1686-11-15, 1704-00-00, Abgesandter, ao, 1699, Obersthofkanzler, K, Envoye, 1701-00-00, Abgesandter, 1704-00-00, Geh. Rat, 1704-00-00)
NLP COMPONENT >>> CreateChunks.py >>> Chunk HOFSTAAT = K
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(5) = [{'DATUM': ['1686-11-15', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}, {'DATUM': ['1699'], 'HOFSTAAT': 'K', 'FUNKTION': ['Abgesandter, ao', 'Obersthofkanzler'], 'AMT': None}, {'DATUM': ['1701-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Envoye'], 'AMT': None}, {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Abgesandter'], 'AMT': None}, {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1686-11-15', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1699'], 'HOFSTAAT': 'K', 'FUNKTION': ['Abgesandter, ao', 'Obersthofkanzler'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	2: chunk: {'DATUM': ['1701-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Envoye'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	3: chunk: {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Abgesandter'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	4: chunk: {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 5, len Ämter-Spalte: 3
helper_hsv_match_hofstaate >>> r_H = L; J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1686-11-15', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1699'], 'HOFSTAAT': 'K', 'FUNKTION': ['Abgesandter, ao', 'Obersthofkanzler'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1701-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Envoye'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1704-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Abgesandter'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1704-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR; OKäA; Abgesandte / Frankreich
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'Dummy Amt'
process_chunks >>> cD ['1686-11-15', 'bis 1704<1704-06-30>'], cF ['Kämmerer'], cH L, CA GR
helper_hsv_post_process_dates >>> old: 1686-11-15, new: 1686-11-15<1686-11-15>
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1686-11-15<1686-11-15>
chunk_process_datum >>> rel, chunk edw: 1686-11-15<1686-11-15>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1686-11-15<1686-11-15>', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1223 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1223 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7087 -- Sinzendorf, Philipp Ludwig -- {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1686-11-15<1686-11-15>', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}
process_chunks >>> cD ['1699'], cF ['Abgesandter, ao', 'Obersthofkanzler'], cH K, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1699, new: 1699<1699-06-30>
chunk_process_datum >>> rel, chunk sdw: 1699<1699-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1699<1699-06-30>'}
chunk_get_nm_hst >>> c_H = K
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: K (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (K (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (K (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Abgesandter, ao', 'Obersthofkanzler']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Abgesandter, ao
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Obersthofkanzler
process_chunks >>>  Source Person Relation: 7087 -- Sinzendorf, Philipp Ludwig -- {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1699<1699-06-30>', 'related_institution': <Institution: Dummy Amt (K (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Obersthofkanzler>}
process_chunks >>> cD ['1701-00-00'], cF ['Envoye'], cH L, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1701-00-00, new: 1701<1701-06-30>
chunk_process_datum >>> rel, chunk sdw: 1701<1701-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1701<1701-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Envoye']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Envoye
process_chunks >>>  Source Person Relation: 7087 -- Sinzendorf, Philipp Ludwig -- {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1701<1701-06-30>', 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Envoye>}
process_chunks >>> cD ['1704-00-00'], cF ['Abgesandter'], cH L, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1704-00-00, new: 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1704<1704-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Abgesandter']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Abgesandter
process_chunks >>>  Source Person Relation: 7087 -- Sinzendorf, Philipp Ludwig -- {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1704<1704-06-30>', 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Abgesandter>}
process_chunks >>> cD ['1704-00-00'], cF ['Geh. Rat'], cH L, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1704-00-00, new: 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1704<1704-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7087 -- Sinzendorf, Philipp Ludwig -- {'related_person': <Person: Sinzendorf, Philipp Ludwig>, 'start_date_written': '1704<1704-06-30>', 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7088 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(2) = [{'DATUM': ['1669-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}, {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis1678-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1669-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis1678-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 2, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1669-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis1678-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA; RHR / Grafen- u. Herrenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt ' RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD ['1669-00-00'], cF ['Reichshofrat'], cH L, CA OKäA
helper_hsv_post_process_dates >>> old: 1669-00-00, new: 1669<1669-06-30>
chunk_process_datum >>> rel, chunk sdw: 1669<1669-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Rudolph>, 'start_date_written': '1669<1669-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1218 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1218 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7088 -- Sinzendorf, Rudolph -- {'related_person': <Person: Sinzendorf, Rudolph>, 'start_date_written': '1669<1669-06-30>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}
process_chunks >>> cD ['1672/73-00-00<1672-06-30 - 73-00-00>', 'bis1678-00-00'], cF ['Kämmerer'], cH L, CA RHR
helper_hsv_post_process_dates >>> inner date: <1672-06-30 - 73-00-00>
helper_hsv_post_process_dates >>> new_i_date: <1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> old: 1672/73-00-00<1672-06-30 - 73-00-00>, new: 1672/73-00-00<1672-06-30 - 73-06-30>
helper_hsv_post_process_dates >>> old: bis1678-00-00, new: bis1678-00-00
chunk_process_datum >>> rel, chunk sdw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>> rel, chunk edw: 1672/73-00-00<1672-06-30 - 73-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Rudolph>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis1678-00-00'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1209 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1209 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
parse_date >>>  APIS: Could not parse date: ' bis1678-00-00 ' due to error month must be in 1..12: 
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7088 -- Sinzendorf, Rudolph -- {'related_person': <Person: Sinzendorf, Rudolph>, 'start_date_written': '1672/73-00-00<1672-06-30 - 73-06-30>', 'end_date_written': 'bis1678-00-00', 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7089 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1684-02-29/(', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1684-02-29/(', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1684-02-29/(', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD ['1684-02-29/(', 'bis 1704<1704-06-30>'], cF ['Kämmerer'], cH L, CA OKäA
helper_hsv_post_process_dates >>> old: 1684-02-29/(, new: 1684-02-29/(
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1684-02-29/(
chunk_process_datum >>> rel, chunk edw: 1684-02-29/(
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Theodor>, 'start_date_written': '1684-02-29/(', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1268 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1268 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
parse_date_range_individual >>> APIS: Could not interpret date: <class 'ValueError'>
parse_date >>>  APIS: Could not parse date: ' 1684-02-29/( ' due to error Could not interpret date.: 
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7089 -- Sinzendorf, Theodor -- {'related_person': <Person: Sinzendorf, Theodor>, 'start_date_written': '1684-02-29/(', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7090 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(2) = [{'DATUM': ['1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}, {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'bis 1704<1704-06-30>'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
NLP COMPONENT >>> CreateChunks.py >>> 	1: chunk: {'DATUM': ['1704-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 2, len Ämter-Spalte: 2
helper_hsv_match_hofstaate >>> r_H = ksl.; L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: ksl.
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: ksl.
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h:  L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'bis 1704<1704-06-30>'], 'HOFSTAAT': 'ksl.', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1704-00-00'], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR; OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> replaced amt ' OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD ['1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'bis 1704<1704-06-30>'], cF ['Kämmerer'], cH ksl., CA GR
helper_hsv_post_process_dates >>> inner date: <1678-05-31 - 1678-06-06>
helper_hsv_post_process_dates >>> new_i_date: <1678-05-31 - 1678-06-06>
helper_hsv_post_process_dates >>> old: 1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>, new: 1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>
helper_hsv_post_process_dates >>> inner date: <1704-06-30>
helper_hsv_post_process_dates >>> new_i_date: <1704-06-30>
helper_hsv_post_process_dates >>> old: bis 1704<1704-06-30>, new: bis 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>
chunk_process_datum >>> rel, chunk edw: 1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Wenzel >, 'start_date_written': '1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'end_date_written': 'bis 1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = ksl.
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1255 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1255 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7090 -- Sinzendorf, Wenzel  -- {'related_person': <Person: Sinzendorf, Wenzel >, 'start_date_written': '1678-05-31/1678-06-06<1678-05-31 - 1678-06-06>', 'end_date_written': 'bis 1704<1704-06-30>', 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}
process_chunks >>> cD ['1704-00-00'], cF ['Geh. Rat, wirkl.'], cH L, CA OKäA
helper_hsv_post_process_dates >>> old: 1704-00-00, new: 1704<1704-06-30>
chunk_process_datum >>> rel, chunk sdw: 1704<1704-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, Wenzel >, 'start_date_written': '1704<1704-06-30>'}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
parse_date_range_individual >>> APIS: Could not interpret date: <class 'ValueError'>
parse_date >>>  APIS: Could not parse date: ' 1684-02-29/( ' due to error Could not interpret date.: 
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1276 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1276 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat, wirkl.
process_chunks >>>  Source Person Relation: 7090 -- Sinzendorf, Wenzel  -- {'related_person': <Person: Sinzendorf, Wenzel >, 'start_date_written': '1704<1704-06-30>', 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat, wirkl.>}

--------- Start of row | 7091 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1677-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1677-00-00'], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1677-00-00'], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1677-00-00'], cF ['Kämmerer'], cH EG, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1677-00-00, new: 1677<1677-06-30>
chunk_process_datum >>> rel, chunk sdw: 1677<1677-06-30>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, NN>, 'start_date_written': '1677<1677-06-30>'}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7091 -- Sinzendorf, NN -- {'related_person': <Person: Sinzendorf, NN>, 'start_date_written': '1677<1677-06-30>', 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7092 | -------------- 
replacer >>> r_fun: replaced ), with: ) ,
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzendorf
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sinzendorf
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': ['1685-11-01'], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': ['1685-11-01'], 'HOFSTAAT': None, 'FUNKTION': ['Edelknabe'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': ['1685-11-01'], 'HOFSTAAT': 'J', 'FUNKTION': ['Edelknabe'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD ['1685-11-01'], cF ['Edelknabe'], cH J, CA Dummy Amt
helper_hsv_post_process_dates >>> old: 1685-11-01, new: 1685-11-01<1685-11-01>
chunk_process_datum >>> rel, chunk sdw: 1685-11-01<1685-11-01>
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzendorf, NN>, 'start_date_written': '1685-11-01<1685-11-01>'}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Edelknabe']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Edelknabe
process_chunks >>>  Source Person Relation: 7092 -- Sinzendorf, NN -- {'related_person': <Person: Sinzendorf, NN>, 'start_date_written': '1685-11-01<1685-11-01>', 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Edelknabe>}

--------- Start of row | 7093 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sinzl (Sintzl)
person_process_field_familienname >>> fam1: Sinzl
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 14), match='(Sintzl)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Heizer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Heizer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Heizer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-HBH-NÖ-BH'
process_chunks >>> cD [], cF ['Heizer'], cH L, CA HK-HBH-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sinzl, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-HBH-NÖ-BH
chunk_process_amt >>> c_A was: HK-HBH-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 918 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 918 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Heizer']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Heizer
process_chunks >>>  Source Person Relation: 7093 -- Sinzl, Peter -- {'related_person': <Person: Sinzl, Peter>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Heizer>}

--------- Start of row | 7094 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Siticki
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Siticki
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Siticki, Paul>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1284 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1284 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7094 -- Siticki, Paul -- {'related_person': <Person: Siticki, Paul>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7095 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitiki
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitiki
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitiki, Paul>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1300 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1300 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7095 -- Sitiki, Paul -- {'related_person': <Person: Sitiki, Paul>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7096 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitiki
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitiki
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitiki, Paul>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1305 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1305 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7096 -- Sitiki, Paul -- {'related_person': <Person: Sitiki, Paul>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7097 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschi, Peter>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1310 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1310 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7097 -- Sitschi, Peter -- {'related_person': <Person: Sitschi, Peter>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7098 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschi, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1315 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1315 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7098 -- Sitschi, Stephan -- {'related_person': <Person: Sitschi, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7099 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschi, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1320 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1320 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7099 -- Sitschi, Stephan -- {'related_person': <Person: Sitschi, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7100 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschi, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1325 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1325 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7100 -- Sitschi, Stephan -- {'related_person': <Person: Sitschi, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7101 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschi [Sitschy]
person_process_field_familienname >>> fam1: Sitschi
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='[Sitschy]'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschi, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1330 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1330 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7101 -- Sitschi, Stephan -- {'related_person': <Person: Sitschi, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7102 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschkhy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschkhy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschkhy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1335 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1335 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7102 -- Sitschkhy, Stephan -- {'related_person': <Person: Sitschkhy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7103 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1340 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1340 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7103 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7104 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1345 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1345 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7104 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7105 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1350 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1350 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7105 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7106 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1355 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1355 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7106 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7107 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1360 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1360 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7107 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7108 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1365 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1365 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7108 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7109 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1370 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1370 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7109 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7110 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1375 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1375 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7110 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7111 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1380 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1380 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7111 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7112 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1385 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1385 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7112 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7113 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1390 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1390 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7113 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7114 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitschy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitschy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitschy, Stephan>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1395 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1395 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7114 -- Sitschy, Stephan -- {'related_person': <Person: Sitschy, Stephan>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7115 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sitting
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sitting
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trabant'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Trabant'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Trabant'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Trabantenleibgarde
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Trabant'], cH J, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sitting, Joachim>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (J1 (Ehzg.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Trabant']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Trabant
process_chunks >>>  Source Person Relation: 7115 -- Sitting, Joachim -- {'related_person': <Person: Sitting, Joachim>, 'related_institution': <Institution: Dummy Amt (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Trabant>}

--------- Start of row | 7116 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sizi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sizi
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sizi, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1400 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1400 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7116 -- Sizi, Georg -- {'related_person': <Person: Sizi, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7117 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sizy
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sizy
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sizy, Georg>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1408 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1408 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7117 -- Sizy, Georg -- {'related_person': <Person: Sizy, Georg>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7118 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Skräwarzs
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Skräwarzs
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Truchseß'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Truchseß'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Truchseß'], cH L, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Skräwarzs, Julius Eusebius>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (L1 (Ks.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Truchseß']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Truchseß
process_chunks >>>  Source Person Relation: 7118 -- Skräwarzs, Julius Eusebius -- {'related_person': <Person: Skräwarzs, Julius Eusebius>, 'related_institution': <Institution: Dummy Amt (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Truchseß>}

--------- Start of row | 7119 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1413 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1413 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7119 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7120 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1421 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1421 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7120 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7121 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1426 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1426 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7121 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7122 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1431 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1431 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7122 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7123 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1436 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1436 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7123 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7124 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1441 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1441 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7124 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7125 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1446 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1446 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7125 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7126 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1451 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1451 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7126 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7127 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1456 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1456 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7127 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7128 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1461 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1461 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7128 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7129 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1466 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1466 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7129 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7130 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1471 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1471 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7130 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7131 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1476 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1476 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7131 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7132 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1481 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1481 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7132 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7133 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1486 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1486 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7133 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7134 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1491 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1491 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7134 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7135 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1281 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1281 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Geh. Rat
process_chunks >>>  Source Person Relation: 7135 -- Slavata, Ferdinand -- {'related_person': <Person: Slavata, Ferdinand>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Geh. Rat>}

--------- Start of row | 7136 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Ferdinand Wilhelm>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1496 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1496 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7136 -- Slavata, Ferdinand Wilhelm -- {'related_person': <Person: Slavata, Ferdinand Wilhelm>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7137 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Hans Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1506 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1506 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7137 -- Slavata, Hans Joachim -- {'related_person': <Person: Slavata, Hans Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7138 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Hans Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1511 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1511 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7138 -- Slavata, Hans Joachim -- {'related_person': <Person: Slavata, Hans Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7139 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1516 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1516 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7139 -- Slavata, Joachim -- {'related_person': <Person: Slavata, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7140 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1521 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1521 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7140 -- Slavata, Johann -- {'related_person': <Person: Slavata, Johann>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7141 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7141 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7142 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (CF (Ksin.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7142 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: OMeA (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7143 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7143 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7144 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7144 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7145 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7145 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7146 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7146 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7147 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7147 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7148 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7148 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7149 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Slavata
person_process_field_titel >>> t_tit = Gräfin
person_process_field_titel >>> t_list = ['Gräfin']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = CF
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: CF
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: CF
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'CF', 'FUNKTION': ['Obersthofmeisterin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Frauenzimmer
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Obersthofmeisterin'], cH CF, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, NN>}
chunk_get_nm_hst >>> c_H = CF
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: CF (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (CF (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (CF (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Obersthofmeisterin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Obersthofmeisterin
process_chunks >>>  Source Person Relation: 7149 -- Slavata, NN -- {'related_person': <Person: Slavata, NN>, 'related_institution': <Institution: Dummy Amt (CF (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Obersthofmeisterin>}

--------- Start of row | 7150 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata (Sclawata)
person_process_field_familienname >>> fam1: Slavata
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 18), match='(Sclawata)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1526 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1526 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7150 -- Slavata, Joachim -- {'related_person': <Person: Slavata, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7151 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka (Schlawata)
person_process_field_familienname >>> fam1: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka
person_process_field_familienname >>> fam2: <re.Match object; span=(64, 75), match='(Schlawata)'>
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer, wirkl.'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1561 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1561 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer, wirkl.
process_chunks >>>  Source Person Relation: 7151 -- Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim -- {'related_person': <Person: Slavata von Chlum u. Koschumberg; Slavata z Chlumu a Kosumberka, Joachim>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer, wirkl.>}

--------- Start of row | 7152 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Socbey (?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Socbey ?
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Socbey ?, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7152 -- Socbey ?, NN -- {'related_person': <Person: Socbey ?, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7153 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sodiz/Hodiz(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sodiz/Hodiz?
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sodiz/Hodiz?, Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1566 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1566 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7153 -- Sodiz/Hodiz?, Maximilian -- {'related_person': <Person: Sodiz/Hodiz?, Maximilian>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7154 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soewey [Sorbey; Sorbait, de?]
person_process_field_familienname >>> Init test: 'de in fam' INPUT: Soewey [Sorbey; Sorbait, de?] END INPUT, ROW:7154
person_process_field_familienname >>> fam1: Soewey
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 29), match='[Sorbey; Sorbait, de?]'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofmediziner'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Hofmediziner'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Offiziere u.a. Bediente
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Hofmediziner'], cH EG, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soewey, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (EG (KW)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Hofmediziner']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofmediziner
process_chunks >>>  Source Person Relation: 7154 -- Soewey, NN -- {'related_person': <Person: Soewey, NN>, 'related_institution': <Institution: OMeA (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Hofmediziner>}

--------- Start of row | 7155 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söhlen
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söhlen
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söhlen, Rudolph Caspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
parse_date >>>  APIS: Could not parse date: ' bis1678-00-00 ' due to error month must be in 1..12: 
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1271 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1271 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7155 -- Söhlen, Rudolph Caspar -- {'related_person': <Person: Söhlen, Rudolph Caspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7156 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sohlental (Söhlenthal)
person_process_field_familienname >>> fam1: Sohlental
person_process_field_familienname >>> fam2: <re.Match object; span=(10, 22), match='(Söhlenthal)'>
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenstand, AC
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sohlental, Rudolph Kaspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1585 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1585 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7156 -- Sohlental, Rudolph Kaspar -- {'related_person': <Person: Sohlental, Rudolph Kaspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7157 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söhlenthal
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söhlenthal
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Ritter- u. Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söhlenthal, Rudolph Kaspar>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1590 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1590 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7157 -- Söhlenthal, Rudolph Kaspar -- {'related_person': <Person: Söhlenthal, Rudolph Kaspar>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7158 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soiber (Stöbern)
person_process_field_familienname >>> fam1: Soiber
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 16), match='(Stöbern)'>
person_process_field_titel >>> t_tit = Edler
person_process_field_titel >>> t_list = ['Edler']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Resident'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Resident'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Resident'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / kurfürst. Residenten
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Resident'], cH Dummy Hofstaat, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soiber, Johann Ferdinand>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name RHRat (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = RHRat (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Resident']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Resident
process_chunks >>>  Source Person Relation: 7158 -- Soiber, Johann Ferdinand -- {'related_person': <Person: Soiber, Johann Ferdinand>, 'related_institution': <Institution: RHRat (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Resident>}

--------- Start of row | 7159 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solar
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solar
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solar, Viktor Amadeus>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1574 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1574 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7159 -- Solar, Viktor Amadeus -- {'related_person': <Person: Solar, Viktor Amadeus>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7160 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solb [Selb]
person_process_field_familienname >>> fam1: Solb
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 11), match='[Selb]'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solb, Johann Gabriel>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1226 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1226 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 7160 -- Solb, Johann Gabriel -- {'related_person': <Person: Solb, Johann Gabriel>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 7161 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solimanno
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solimanno
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Postinbereiter', 'Pästinbereiter'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OStA / Hoffuttermeister
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OStA ' with 'OStA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OStA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OStA'
process_chunks >>> cD [], cF ['Postinbereiter', 'Pästinbereiter'], cH L, CA OStA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solimanno, Gabriel Francesco>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OStA
chunk_process_amt >>> c_A was: OStA and amt after matching with amt index is: OStA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OStA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 867 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Set InstInst Relation for OStA (L1 (Ks.)) from OStA (L1 (Ks.)), 867 to OStA (L1 (Ks.)), 283
db_deduplicate_aemter >>> Deleted obsolete Institution OStA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OStA (L1 (Ks.)) is OStA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OStA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OStA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Postinbereiter', 'Pästinbereiter']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Postinbereiter
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Pästinbereiter
process_chunks >>>  Source Person Relation: 7161 -- Solimanno, Gabriel Francesco -- {'related_person': <Person: Solimanno, Gabriel Francesco>, 'related_institution': <Institution: OStA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Pästinbereiter>}

--------- Start of row | 7162 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1003 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1003 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7162 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7163 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1619 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1619 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7163 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7164 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1624 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1624 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7164 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7165 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Soll
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1629 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1629 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7165 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7166 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll [Salla]
person_process_field_familienname >>> fam1: Soll
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='[Salla]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1634 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1634 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7166 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7167 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Soll [Salla]
person_process_field_familienname >>> fam1: Soll
person_process_field_familienname >>> fam2: <re.Match object; span=(5, 12), match='[Salla]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Soll, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1639 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1639 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7167 -- Soll, Christian -- {'related_person': <Person: Soll, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7168 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solle
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solle
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Regimentsrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Regimentsrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ(?) / Gelehrtenstand
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ(?) ' with 'NÖ'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Regimentsrat']'
process_chunks >>> cD [], cF ['Regimentsrat'], cH L, CA NÖ
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solle, Maximilian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ
chunk_process_amt >>> c_A was: NÖ and amt after matching with amt index is: NÖ (manuell), type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ (manuell) (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ (manuell) (L1 (Ks.)) from NÖ (manuell) (L1 (Ks.)), 854 to NÖ (manuell) (L1 (Ks.)), 29
db_deduplicate_aemter >>> Set InstInst Relation for NÖ (manuell) (L1 (Ks.)) from NÖ (manuell) (L1 (Ks.)), 854 to NÖ (manuell) (L1 (Ks.)), 29
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ (manuell) (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ (manuell) (L1 (Ks.)) is NÖ (manuell) (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ (manuell) (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ (manuell) (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Regimentsrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Regimentsrat
process_chunks >>>  Source Person Relation: 7168 -- Solle, Maximilian -- {'related_person': <Person: Solle, Maximilian>, 'related_institution': <Institution: NÖ (manuell) (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Regimentsrat>}

--------- Start of row | 7169 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solliciti
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solliciti
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solliciti, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1644 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1644 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7169 -- Solliciti, Christian -- {'related_person': <Person: Solliciti, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7170 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollinti(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollinti?
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollinti?, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1654 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1654 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7170 -- Sollinti?, Christian -- {'related_person': <Person: Sollinti?, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7171 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollinti(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollinti?
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-R / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-R ' with 'NÖ-R'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-R
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-R'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA NÖ-R
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollinti?, Christian>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-R
chunk_process_amt >>> c_A was: NÖ-R and amt after matching with amt index is: NÖ Reg., type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Reg. (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1659 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Reg. (L1 (Ks.)) from NÖ Reg. (L1 (Ks.)), 1659 to NÖ Reg. (L1 (Ks.)), 16
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Reg. (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Reg. (L1 (Ks.)) is NÖ Reg. (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent NÖ Reg. (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Reg. (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7171 -- Sollinti?, Christian -- {'related_person': <Person: Sollinti?, Christian>, 'related_institution': <Institution: NÖ Reg. (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7172 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sollner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7172 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7173 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7173 -- Söllner, Eva -- {'related_person': <Person: Söllner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7174 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7174 -- Söllner, Eva -- {'related_person': <Person: Söllner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7175 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Silberwäscher'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Silberwäscher'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Johann Michael>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 731 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 731 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 731 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (J1 (Ehzg.)) is OMeA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Silberwäscher']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Silberwäscher
process_chunks >>>  Source Person Relation: 7175 -- Söllner, Johann Michael -- {'related_person': <Person: Söllner, Johann Michael>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Silberwäscher>}

--------- Start of row | 7176 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Söllner
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Söllner
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Silberwäscher'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Silberwäscher'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Silberwäscher'], cH J, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Söllner, Johann Michael>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 1678 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (J1 (Ehzg.)) from OMeA (J1 (Ehzg.)), 1678 to OMeA (J1 (Ehzg.)), 7
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (J1 (Ehzg.)) is OMeA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Silberwäscher']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Silberwäscher
process_chunks >>>  Source Person Relation: 7176 -- Söllner, Johann Michael -- {'related_person': <Person: Söllner, Johann Michael>, 'related_institution': <Institution: OMeA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Silberwäscher>}

--------- Start of row | 7177 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söldner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söldner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, NN>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7177 -- Sollner, NN -- {'related_person': <Person: Sollner, NN>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7178 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söllner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söllner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7178 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7179 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sollner (Söllner)
person_process_field_familienname >>> fam1: Sollner
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 17), match='(Söllner)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EM
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EM
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EM
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EM', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammer- u. Hoffräulein)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammer- u. Hoffräulein)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH EM, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sollner, Eva>}
chunk_get_nm_hst >>> c_H = EM
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EM (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EM (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EM (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7179 -- Sollner, Eva -- {'related_person': <Person: Sollner, Eva>, 'related_institution': <Institution: Dummy Amt (EM (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7180 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Reichshofrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Reichshofrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = RHR / Grafen- u. Herrenbank
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> replaced amt 'RHR ' with 'RHR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = RHR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'RHR'
process_chunks >>> cD [], cF ['Reichshofrat'], cH L, CA RHR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: RHR
chunk_process_amt >>> c_A was: RHR and amt after matching with amt index is: RHRat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name RHRat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1595 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Set InstInst Relation for RHRat (L1 (Ks.)) from RHRat (L1 (Ks.)), 1595 to RHRat (L1 (Ks.)), 1208
db_deduplicate_aemter >>> Deleted obsolete Institution RHRat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for RHRat (L1 (Ks.)) is RHRat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (Reich)
get_or_create_amt >>> Created amt_ent RHRat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = RHRat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Reichshofrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Reichshofrat
process_chunks >>>  Source Person Relation: 7180 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: RHRat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Reichshofrat>}

--------- Start of row | 7181 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerpräsident'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerpräsident'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 0
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Kammerpräsident'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = nan
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'None'
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerpräsident'], cH Dummy Hofstaat, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Kammerpräsident']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerpräsident
process_chunks >>>  Source Person Relation: 7181 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: Dummy Amt (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Kammerpräsident>}

--------- Start of row | 7182 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Solms
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Solms
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at start of call = (Titular Geh. Rat,)
NLP COMPONENT >>> UseExistingAnnotations.py >>> compare docs
NLP COMPONENT >>> UseExistingAnnotations.py >>> THIS WAS LOGGED :7182, Titular Geh. Rat, [{'start': 0, 'end': 16, 'token_start': 0, 'token_end': 3, 'label': 'FUNKTION'}]
NLP COMPONENT >>> UseExistingAnnotations.py >>> lst_ents = [Titular Geh. Rat]
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc.ents at end of call = (Titular Geh. Rat,)
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Titular Geh. Rat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = GR
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> replaced amt 'GR' with 'GR'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = GR
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'GR'
process_chunks >>> cD [], cF ['Titular Geh. Rat'], cH L, CA GR
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Solms, Friedrich Ernst>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: GR
chunk_process_amt >>> c_A was: GR and amt after matching with amt index is: Geh. Rat, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Geh. Rat (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1501 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Set InstInst Relation for Geh. Rat (L1 (Ks.)) from Geh. Rat (L1 (Ks.)), 1501 to Geh. Rat (L1 (Ks.)), 289
db_deduplicate_aemter >>> Deleted obsolete Institution Geh. Rat (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Geh. Rat (L1 (Ks.)) is Geh. Rat (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Geh. Rat (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Geh. Rat (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Titular Geh. Rat']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Titular Geh. Rat
process_chunks >>>  Source Person Relation: 7182 -- Solms, Friedrich Ernst -- {'related_person': <Person: Solms, Friedrich Ernst>, 'related_institution': <Institution: Geh. Rat (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Titular Geh. Rat>}

--------- Start of row | 7183 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommer
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommer
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Konzipist'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Konzipist'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG / Kanzleiverwandte
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG ' with 'NÖ-LG'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG'
process_chunks >>> idx_chunk == 0 and idx in missing funcs keys.
process_chunks >>> Before check for empty c_F: c_F = '['Konzipist']'
process_chunks >>> cD [], cF ['Konzipist'], cH L, CA NÖ-LG
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommer, Niklas>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: NÖ-LG
chunk_process_amt >>> c_A was: NÖ-LG and amt after matching with amt index is: NÖ Landmarsch. Gericht, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ Landmarsch. Gericht (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 1230 to NÖ Landmarsch. Gericht (L1 (Ks.)), 1229
db_deduplicate_aemter >>> Set InstInst Relation for NÖ Landmarsch. Gericht (L1 (Ks.)) from NÖ Landmarsch. Gericht (L1 (Ks.)), 1230 to NÖ Landmarsch. Gericht (L1 (Ks.)), 1229
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ Landmarsch. Gericht (L1 (Ks.)) is NÖ Landmarsch. Gericht (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Gerichtsbarkeit
get_or_create_amt >>> Created amt_ent NÖ Landmarsch. Gericht (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ Landmarsch. Gericht (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Konzipist']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Konzipist
process_chunks >>>  Source Person Relation: 7183 -- Sommer, Niklas -- {'related_person': <Person: Sommer, Niklas>, 'related_institution': <Institution: NÖ Landmarsch. Gericht (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Konzipist>}

--------- Start of row | 7184 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommer (Sammer)
person_process_field_familienname >>> fam1: Sommer
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sammer)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Raitoffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Raitoffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-HBH-NÖ-BH' with 'HK-HBH-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-HBH-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-HBH-NÖ-BH'
process_chunks >>> cD [], cF ['Raitoffizier'], cH L, CA HK-HBH-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommer, Johann Konrad>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK-HBH-NÖ-BH
chunk_process_amt >>> c_A was: HK-HBH-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name NÖ BH (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 1295 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Set InstInst Relation for NÖ BH (L1 (Ks.)) from NÖ BH (L1 (Ks.)), 1295 to NÖ BH (L1 (Ks.)), 746
db_deduplicate_aemter >>> Deleted obsolete Institution NÖ BH (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for NÖ BH (L1 (Ks.)) is NÖ BH (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent NÖ BH (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = NÖ BH (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Raitoffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Raitoffizier
process_chunks >>>  Source Person Relation: 7184 -- Sommer, Johann Konrad -- {'related_person': <Person: Sommer, Johann Konrad>, 'related_institution': <Institution: NÖ BH (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Raitoffizier>}

--------- Start of row | 7185 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener, wirkl.'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 862 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 862 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kammerdiener, wirkl.
process_chunks >>>  Source Person Relation: 7185 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener, wirkl.>}

--------- Start of row | 7186 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = J
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: J
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: J
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'J', 'FUNKTION': ['Kammerdiener, wirkl.'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener, wirkl.'], cH J, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = J
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: J1 (Ehzg.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (J1 (Ehzg.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 1719 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (J1 (Ehzg.)) from OKäA (J1 (Ehzg.)), 1719 to OKäA (J1 (Ehzg.)), 515
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (J1 (Ehzg.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (J1 (Ehzg.)) is OKäA (J1 (Ehzg.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (J1 (Ehzg.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (J1 (Ehzg.))
chunk_create_relations >>> create relations called for c_F ['Kammerdiener, wirkl.']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener, wirkl.
process_chunks >>>  Source Person Relation: 7186 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (J1 (Ehzg.))>, 'relation_type': <PersonInstitutionRelation: Kammerdiener, wirkl.>}

--------- Start of row | 7187 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sommervogl
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sommervogl
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdiener'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Kammerdiener'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kammerdiener'], cH Dummy Hofstaat, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sommervogl, Joseph Anton>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name OKäA (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = OKäA (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Kammerdiener']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdiener
process_chunks >>>  Source Person Relation: 7187 -- Sommervogl, Joseph Anton -- {'related_person': <Person: Sommervogl, Joseph Anton>, 'related_institution': <Institution: OKäA (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Kammerdiener>}

--------- Start of row | 7188 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somogyi
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Somogyi
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz / Sekretarien
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz ' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz ' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somogyi, Franz >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7188 -- Somogyi, Franz  -- {'related_person': <Person: Somogyi, Franz >, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7189 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somogyi (Somogy)
person_process_field_familienname >>> fam1: Somogyi
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Somogy)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Sekretär'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Sekretär'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Sekretär'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somogyi, Franz>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Ung. HKz (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 1733 to Ung. HKz (L1 (Ks.)), 1732
db_deduplicate_aemter >>> Set InstInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 1733 to Ung. HKz (L1 (Ks.)), 1732
db_deduplicate_aemter >>> Deleted obsolete Institution Ung. HKz (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Ung. HKz (L1 (Ks.)) is Ung. HKz (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Sekretär']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Sekretär
process_chunks >>>  Source Person Relation: 7189 -- Somogyi, Franz -- {'related_person': <Person: Somogyi, Franz>, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Sekretär>}

--------- Start of row | 7190 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Somosa
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Somosa
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = MMT
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: MMT
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: MMT
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'MMT', 'FUNKTION': ['Kammerdienerin'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = (Kammerdienerinnen)
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerdienerinnen)' with ''
helper_hsv_match_amt_with_funct >>> replaced amt '(Kammerdienerinnen)' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerdienerin'], cH MMT, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Somosa, Antonia>}
chunk_get_nm_hst >>> c_H = MMT
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: MMT (Ksin.)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (MMT (Ksin.))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (MMT (Ksin.))
chunk_create_relations >>> create relations called for c_F ['Kammerdienerin']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerdienerin
process_chunks >>>  Source Person Relation: 7190 -- Somosa, Antonia -- {'related_person': <Person: Somosa, Antonia>, 'related_institution': <Institution: Dummy Amt (MMT (Ksin.))>, 'relation_type': <PersonInstitutionRelation: Kammerdienerin>}

--------- Start of row | 7191 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonces
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felice>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1178 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1178 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7191 -- Sonces, Felice -- {'related_person': <Person: Sonces, Felice>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7192 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces (Sances)
person_process_field_familienname >>> fam1: Sonces
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sances)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felice>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1748 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1748 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7192 -- Sonces, Felice -- {'related_person': <Person: Sonces, Felice>, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7193 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonces (Sances)
person_process_field_familienname >>> fam1: Sonces
person_process_field_familienname >>> fam2: <re.Match object; span=(7, 15), match='(Sances)'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kapellmeister'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kapellmeister'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OMeA / Hofmusik
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OMeA ' with 'OMeA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OMeA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OMeA'
process_chunks >>> cD [], cF ['Kapellmeister'], cH L, CA OMeA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonces, Felici >}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OMeA
chunk_process_amt >>> c_A was: OMeA and amt after matching with amt index is: OMeA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OMeA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1753 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Set InstInst Relation for OMeA (L1 (Ks.)) from OMeA (L1 (Ks.)), 1753 to OMeA (L1 (Ks.)), 246
db_deduplicate_aemter >>> Deleted obsolete Institution OMeA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OMeA (L1 (Ks.)) is OMeA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OMeA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OMeA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kapellmeister']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kapellmeister
process_chunks >>>  Source Person Relation: 7193 -- Sonces, Felici  -- {'related_person': <Person: Sonces, Felici >, 'related_institution': <Institution: OMeA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kapellmeister>}

--------- Start of row | 7194 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonnau
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonnau
person_process_field_titel >>> t_tit = Graf
person_process_field_titel >>> t_list = ['Graf']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonnau, Franz Anton>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1603 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1603 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7194 -- Sonnau, Franz Anton -- {'related_person': <Person: Sonnau, Franz Anton>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7195 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonniz(?)
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonniz?
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkammerrat'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK' with 'HK'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK'
process_chunks >>> cD [], cF ['Hofkammerrat'], cH L, CA HK
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonniz?, Johann>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: HK
chunk_process_amt >>> c_A was: HK and amt after matching with amt index is: HK, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name HK (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1608 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Set InstInst Relation for HK (L1 (Ks.)) from HK (L1 (Ks.)), 1608 to HK (L1 (Ks.)), 125
db_deduplicate_aemter >>> Deleted obsolete Institution HK (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for HK (L1 (Ks.)) is HK (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Finanzwesen
get_or_create_amt >>> Created amt_ent HK (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = HK (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkammerrat']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkammerrat
process_chunks >>>  Source Person Relation: 7195 -- Sonniz?, Johann -- {'related_person': <Person: Sonniz?, Johann>, 'related_institution': <Institution: HK (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Hofkammerrat>}

--------- Start of row | 7196 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonntag
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonntag
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> replaced amt 'HK-NÖ-BH' with 'HK-NÖ-BH'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = HK-NÖ-BH
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'HK-NÖ-BH'
process_chunks >>> cD [], cF ['Buchhaltereioffizier'], cH Dummy Hofstaat, CA HK-NÖ-BH
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonntag, Johann Georg>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: HK-NÖ-BH
chunk_process_amt >>> c_A was: HK-NÖ-BH and amt after matching with amt index is: NÖ BH, type amt: <class 'str'>
chunk_process_amt >>> Skipped writing InstitutionInstitution relation for amt_name NÖ BH (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ BH (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Buchhaltereioffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Buchhaltereioffizier
process_chunks >>>  Source Person Relation: 7196 -- Sonntag, Johann Georg -- {'related_person': <Person: Sonntag, Johann Georg>, 'related_institution': <Institution: NÖ BH (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Buchhaltereioffizier>}

--------- Start of row | 7197 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> sonntag
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = sonntag
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = nan
helper_hsv_match_hofstaate >>> chunk Hofstaat = Dummy Hofstaat
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'Dummy Hofstaat', 'FUNKTION': ['Buchhaltereioffizier'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = NÖ-LG? / Buchhaltereioffiziere
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> replaced amt 'NÖ-LG? ' with 'NÖ-LG?'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = NÖ-LG?
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'NÖ-LG?'
process_chunks >>> cD [], cF ['Buchhaltereioffizier'], cH Dummy Hofstaat, CA NÖ-LG?
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: sonntag, Johann Georg>}
chunk_get_nm_hst >>> c_H = Dummy Hofstaat
chunk_process_amt >>> c_A in if c_A true: NÖ-LG?
chunk_process_amt >>> amt NÖ-LG? was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt NÖ-LG? (Dummy Hofstaat)
chunk_process_amt >>>  Return value of inst2 = NÖ-LG? (Dummy Hofstaat)
chunk_create_relations >>> create relations called for c_F ['Buchhaltereioffizier']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Buchhaltereioffizier
process_chunks >>>  Source Person Relation: 7197 -- sonntag, Johann Georg -- {'related_person': <Person: sonntag, Johann Georg>, 'related_institution': <Institution: NÖ-LG? (Dummy Hofstaat)>, 'relation_type': <PersonInstitutionRelation: Buchhaltereioffizier>}

--------- Start of row | 7198 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sonsky
person_process_field_familienname >>> Used fam1_ = familienname.strip(), fam1_ = Sonsky
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Hofkanzler', 'Bischof'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = UHKz
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> replaced amt 'UHKz' with 'UHKz'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = UHKz
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'UHKz'
process_chunks >>> cD [], cF ['Hofkanzler', 'Bischof'], cH L, CA UHKz
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sonsky, Ladislaus Matthias>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: UHKz
chunk_process_amt >>> c_A was: UHKz and amt after matching with amt index is: Ung. HKz, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name Ung. HKz (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 1738 to Ung. HKz (L1 (Ks.)), 1732
db_deduplicate_aemter >>> Set InstInst Relation for Ung. HKz (L1 (Ks.)) from Ung. HKz (L1 (Ks.)), 1738 to Ung. HKz (L1 (Ks.)), 1732
db_deduplicate_aemter >>> Deleted obsolete Institution Ung. HKz (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for Ung. HKz (L1 (Ks.)) is Ung. HKz (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1
get_or_create_amt >>> isnt_type == Verwaltungswesen (ldsftl.)
get_or_create_amt >>> Created amt_ent Ung. HKz (L1 (Ks.)), amt_super L1
chunk_process_amt >>>  Return value of inst2 = Ung. HKz (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Hofkanzler', 'Bischof']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Hofkanzler
chunk_create_relations >>> PersonInstitutionRelation created returned: True; rel['relation_type'] = Bischof
process_chunks >>>  Source Person Relation: 7198 -- Sonsky, Ladislaus Matthias -- {'related_person': <Person: Sonsky, Ladislaus Matthias>, 'related_institution': <Institution: Ung. HKz (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Bischof>}

--------- Start of row | 7199 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau [Saurau?]
person_process_field_familienname >>> fam1: Sorau
person_process_field_familienname >>> fam2: <re.Match object; span=(6, 15), match='[Saurau?]'>
person_process_field_titel >>> t_tit = Freiherr
person_process_field_titel >>> t_list = ['Freiherr']
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kämmerer'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = L
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: L
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: L
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'L', 'FUNKTION': ['Kämmerer'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A = OKäA
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> replaced amt 'OKäA' with 'OKäA'
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = OKäA
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = 'OKäA'
process_chunks >>> cD [], cF ['Kämmerer'], cH L, CA OKäA
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, Johann Carl>}
chunk_get_nm_hst >>> c_H = L
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: L1 (Ks.)
chunk_process_amt >>> c_A in if c_A true: OKäA
chunk_process_amt >>> c_A was: OKäA and amt after matching with amt index is: OKäA, type amt: <class 'str'>
chunk_process_amt >>> Exception caught for duplicates for amt_name OKäA (L1 (Ks.)). Calling db_deduplicate_aemter
db_deduplicate_aemter >>> Set PersInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1763 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Set InstInst Relation for OKäA (L1 (Ks.)) from OKäA (L1 (Ks.)), 1763 to OKäA (L1 (Ks.)), 240
db_deduplicate_aemter >>> Deleted obsolete Institution OKäA (L1 (Ks.))
chunk_process_amt >>> Exception resolved: inst2 is for OKäA (L1 (Ks.)) is OKäA (L1 (Ks.))
get_or_create_amt >>> name_hst_2 == L1 (Ks.)
get_or_create_amt >>> isnt_type == Hofstaat
get_or_create_amt >>> Created amt_ent OKäA (L1 (Ks.)), amt_super L1 (Ks.)
chunk_process_amt >>>  Return value of inst2 = OKäA (L1 (Ks.))
chunk_create_relations >>> create relations called for c_F ['Kämmerer']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kämmerer
process_chunks >>>  Source Person Relation: 7199 -- Sorau, Johann Carl -- {'related_person': <Person: Sorau, Johann Carl>, 'related_institution': <Institution: OKäA (L1 (Ks.))>, 'relation_type': <PersonInstitutionRelation: Kämmerer>}

--------- Start of row | 7200 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau, von [Serau, von]
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sorau, von [Serau, von] END INPUT, ROW:7200
person_process_field_familienname >>> fam1: Sorau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 23), match='[Serau, von]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7200 -- Sorau, von, NN -- {'related_person': <Person: Sorau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7201 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorau, von [Serau, von]
person_process_field_familienname >>> Init test: 'von in fam' INPUT: Sorau, von [Serau, von] END INPUT, ROW:7201
person_process_field_familienname >>> fam1: Sorau, von
person_process_field_familienname >>> fam2: <re.Match object; span=(11, 23), match='[Serau, von]'>
NLP COMPONENT >>> UseExistingAnnotations.py >>> Entered call
NLP COMPONENT >>> UseExistingAnnotations.py >>> doc._excel_row was not in annotations.keys
NLP COMPONENT >>> CreateChunks.py >>> this was finally written, chunk(1) = [{'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}]
NLP COMPONENT >>> CreateChunks.py >>> 	0: chunk: {'DATUM': [], 'HOFSTAAT': None, 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
process_chunks >>> len_doc_chunks: 1, len Ämter-Spalte: 1
helper_hsv_match_hofstaate >>> r_H = EG
helper_hsv_match_hofstaate >>> HOFSTAATE PROCESSING ----> h: EG
helper_hsv_match_hofstaate >>> NO CHUNK HOFSTAAT
helper_hsv_match_hofstaate >>> chunk Hofstaat set to: EG
helper_hsv_match_hofstaate >>> chunk is -- > {'DATUM': [], 'HOFSTAAT': 'EG', 'FUNKTION': ['Kammerfräulein'], 'AMT': None}
helper_hsv_match_amt_with_funct >>> r_A =  / Kammer- u. Hoffräulein
helper_hsv_match_amt_with_funct >>> replaced amt '' with ''
helper_hsv_match_amt_with_funct >>> replaced amt ' ' with ''
helper_hsv_match_amt_with_funct >>> r_A equals len(Chunks) -> c[amt] = 
helper_hsv_match_amt_with_funct >>> Before check for empty amt, c[amt] = ''
helper_hsv_match_amt_with_funct >>> Caught Empty Amt -> c[amt] set to = Dummy Amt
process_chunks >>> cD [], cF ['Kammerfräulein'], cH EG, CA Dummy Amt
chunk_process_datum >>>  this is the full relation: {'related_person': <Person: Sorau, von, NN>}
chunk_get_nm_hst >>> c_H = EG
chunk_create_institution >>> nm_hst is not Dummy Hofstaat: EG (KW)
chunk_process_amt >>> c_A in if c_A true: Dummy Amt
chunk_process_amt >>> amt Dummy Amt was not in df_aemter_index
chunk_process_amt >>> Skipped writing InstitutionInstituion relation because row_target was None for amt Dummy Amt (EG (KW))
chunk_process_amt >>>  Return value of inst2 = Dummy Amt (EG (KW))
chunk_create_relations >>> create relations called for c_F ['Kammerfräulein']
chunk_create_relations >>> PersonInstitutionRelation created returned: False; rel['relation_type'] = Kammerfräulein
process_chunks >>>  Source Person Relation: 7201 -- Sorau, von, NN -- {'related_person': <Person: Sorau, von, NN>, 'related_institution': <Institution: Dummy Amt (EG (KW))>, 'relation_type': <PersonInstitutionRelation: Kammerfräulein>}

--------- Start of row | 7202 | -------------- 
person_process_field_vorname >>> r_vor
person_process_field_familienname >>> Sorbait (Sorbey)
person_process_field_familienname >>> fam1: Sorbait
person_process_field_familienname >>> fam2: <re.Match object; span=(8, 16), match='(Sorbey)'>
person_process_field_titel >>> t_tit = Dr.med.
person_process_field_titel >>> t_list = ['Dr.med.']
